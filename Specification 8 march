\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{ upgreek }
\usepackage{mathpartir}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{tcolorbox}

\input{macros}

\begin{document}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% 15/02/2019
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\begin{flushleft}
  \namedRuleform{ \progTyping{\imEnv}{\tyEnv}{pgm}{\type} }
                {Program Typing}
\end{flushleft}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
\inferrule*[right=Expression]
           {\tcTerm{\imEnv}{\tyEnv}{expr}{\type}}
           {\progTyping{\imEnv}{\tyEnv}{expr}{\type}}

           
           \\[5mm]
           \inferrule*[right=implicit]
                      {\imEnvBuild{\imEnv}{\tyEnv}{impl}{\imEnv'}\ \\\progTyping{\imEnv'}{\tyEnv}{pgm}{\type} }
                      {\progTyping{\imEnv}{\tyEnv}{impl;pgm}{\type}}

           \\[5mm]
           \inferrule*[right=data]
                      {\tyEnvBuild{\imEnv}{\tyEnv}{data}{\tyEnv'}\ \\\progTyping{\imEnv}{\tyEnv'}{pgm}{\type}}
                      {\progTyping{\imEnv}{\tyEnv}{impl;pgm}{\type}}
\end{array}
\]

\begin{flushleft}
  \namedRuleform{ \imEnvBuild{\imEnv}{\tyEnv}{impl}{\imEnv'} }
                {Building the Implicit Environment}
\end{flushleft}
\[
\inferrule*[]
           {\tcTerm{\imEnv}{\tyEnv}{expr}{\type_1 \rightarrow \type_2}}
           {\imEnvBuild{\imEnv}{\tyEnv}{implicit\;i:\type_1 \rightsquigarrow \type_2 = expr}{\imEnv,i}}
\]

\begin{flushleft}
  \namedRuleform{ \tyEnvBuild{\imEnv}{\tyEnv}{impl}{\imEnv'} }
                {Building the Typing Environment}
\end{flushleft}
\[
\inferrule*[]
           {}
           {\tyEnvBuild{\imEnv}{\tyEnv}{(data\;T\;\tyVar=K\;\overline{\type})}{\tyEnv,T,(K:\tyAbs{\tyVar}{\overline{\type} \rightarrow T\;\tyVar})}}
\]

\begin{flushleft}
  \namedRuleform{ \tcTerm{\imEnv}{\tyEnv}{\term}{\type} }
                {}
\end{flushleft}
\[
\inferrule*[]
           {\infTermTrans{\imEnv}{\tyEnv}{\term}{\type}{*}{*}{\term'}}
           {\tcTerm{\imEnv}{\tyEnv}{\term}{\type}}
\]

\begin{flushleft}
  \namedRuleform{ \infTermTrans{\imEnv}{\tyEnv}{\term}{\type}{\eqCts}{\imCts}{\term'}}
                {Type Inference and Partial Translation}
\end{flushleft}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
  \inferrule*[right=Var]
             {(\tmVar : \type)\in\tyEnv}
             {\infTermTrans{\imEnv}{\tyEnv}{\tmVar}{\type}{\bullet}{\bullet}{\tmVar}}

             \quad\quad
             
  \inferrule*[right=Constr]
             {(K:\forall \tyVar . \type) \in \tyEnv}
             {\infTermTrans{\imEnv}{\tyEnv}{K}{[\tyVar \mapsto \type']\type}{\bullet}{\bullet}{K}}
            \\[5mm]

  \inferrule*[right=Abstraction]
             {\infTermTrans{\imEnv}{\tyEnv,\tmVar:\tyVar}{\term}{\type}{\eqCts}{\imCts}{\term'}}
             {\infTermTrans{\imEnv}{\tyEnv}{\lambda \tmVar . \term}{\tyVar \rightarrow \type}{\eqCts}{\imCts}{\term'}}

\\[5mm]
  
  \inferrule*[right=Application]
  {
  \infTermTrans{\imEnv}{\tyEnv}{\term_1}{\type_1}{\eqCts_1}{\imCts_1}{\term_1'} \\
  \infTermTrans{\imEnv}{\tyEnv}{\term_2}{\type_2}{\eqCts_2}{\imCts_2}{\term_2'}
  \\ fresh\;j
  }
  { \infTermTrans{\imEnv}{\tyEnv}{\term_1 \term_2}{\tyVar}{\eqCts_1 + \eqCts_2 + (\type_1 \sim b \rightarrow a)}{\imCts_1 +\imCts_2 + \namedImRes{\imEnv}{j}{\type_2}{b}}{\term_1'(j \; \term_2')} }
  
  \\[5mm]
  
  \inferrule*[right=Case]
             {(K : \forall a . \overline{\type} \rightarrow T \;a)\in \tyEnv
               \\
               \infTermTrans{\imEnv}{\tyEnv}{e_1}{\type_1}{E_1}{Y_1}{e_1'}
               \\
               \infTermTrans{\imEnv}{\tyEnv,\overline{\tmVar}:[a\mapsto b]\overline{\type}}{e_2}{\type_2}{E_2}{Y_2}{e_2'}
               \\
               fresh\;j
             }
             {\infTermTrans{\imEnv}{\tyEnv}{case\;e_1\;of\;(K\;x)\rightarrow e_2}{\type_2}{E_1+E_2}{Y_1+Y_2+\namedImRes{\imEnv}{j}{\type_1}{T\;b}}{case\;(j\;e_1')\;of\;(K\;\tmVar)\rightarrow e_2'}}

\end{array}
\]

\begin{flushleft}
  \namedRuleform{ \imResSubs{\imEnv}{j}{\type_1}{\type_2}{\Theta}{\varphi}}
                {Implicit Conversion Resolution and Subst}
\end{flushleft}

\[
  \inferrule*[right=Aux]
             {
               \imResiSubs{\bullet}{\imEnv}{j}{\type_1}{\type_2}{\Theta}{\varphi}
             }
             {
               \imResSubs{\imEnv}{j}{\type_1}{\type_2}{\Theta}{\varphi}
             }
  %;[fv(\type_1)\mapsto \overline{\type_{1i}},fv(\type_2)\mapsto \overline{\type_{2i}}]
  \]
  
\begin{flushleft}
  \namedRuleform{ \imResiSubs{\overline{\type}}{\imEnv}{j}{\type_1}{\type_2}{\Theta}{\varphi}}
                {Implicit Conversion Resolution with Loop Detection}
\end{flushleft}

\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}

\inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \imResiSubs{\overline{\type}}{\imEnv}{j}{\type_1}{\type_2}{[j \mapsto id]}{[fv(\type_1)\mapsto \overline{\type_{1i}},fv(\type_2)\mapsto \overline{\type_{2i}}]} }
  \\[5mm]
  \inferrule*[right=Transitivity]
  {
    (\forall \overline{\tyVar}.Cond \Rightarrow \type_1' \rightsquigarrow \type_3'=expr_{fst}) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type_a}]\type_1'
    \\
    \type_3 = [\overline{\tyVar}\mapsto \overline{\type_a}]\type_3'
    \\
    \type_3 \notin \overline{\type}
    \\
    \forall\; cond_i \in [\overline{a} \mapsto \overline{\type_a}]Cond\;:\;(\imResSubs{\imEnv}{cond_i}{\type_{i1}}{\type_{i2}}{\Theta_i}{\varphi_i})
    \\
    \imResiSubs{\overline{\type},\type_1}{\imEnv}{conv_{rest}}{(\overline{\varphi_i}\;\type_3)}{\type_2}{\Theta_{rest}}{\varphi_{rest}}
  }
{ \imResiSubs{\overline{\type}}{\imEnv}{conv}{\type_1}{\type_2}{[conv \mapsto (\Theta_{rest}\;conv_{rest}) \circ (\overline{\Theta_i}\; ([\overline{a} \mapsto \overline{\type_a}]expr_{fst}))]}{\varphi_{rest} \circ \overline{\varphi_i} \circ [\overline{\tyVar}\mapsto \overline{\type_a}]}}
% { \imResiSubs{\overline{\type}}{\imEnv}{conv}{\type_1}{\type_2}{[conv \mapsto (\Theta_{rest}\;conv_{rest}) \circ (conv_{fst}\;\type_a\; \overline{\Theta_i\;cond_i} ))]}}

  \end{array}
\]  

* ::= If all the constraints in E and Y have been satisfied.

\end{document}
