\chapter{TrIC}
\label{cha:5}

We now present TrIC (TRansitive Implicit Conversions), a calculus which showcases the features mentioned in the previous chapter, namely type inference and implicit conversions with support for transitivity, local scoping, constrained and polymorphic conversions.

\section{Syntax}
TrIC extends with HM is the presence of implicit conversions. As such, the focus of this section is on the syntax of this novel feature of the language, namely on the terms that introduce implicit conversions into the language, $locimp$ (short for local implicit), and on the implicit environment they create ($\imEnv$). The latter is crucial for solving the conversion constraints generated by a program, as will be explained in Chapter \ref{cha:6}.

A $locimp$ term $locimp \; i : \typeS_{\rightsquigarrow}=\term_1\; in\; \term_2$ is composed of an implicit conversion ($i : \typeS_{\rightsquigarrow}=\term_1$) and any (sub)term $\term_2$. Similarly to how a $let$ expression extends the typing environment $\tyEnv$ for its right hand side term, a $locimp$ expression extends the implicit environment ($\imEnv$) under which its expression $\term$ is typed. 

Implicit conversions are given a name, specify a conversion type and introduce a term. A conversion type is either a conversion monotype or a conversion polytype. Conversion monotypes ($\convmono=\type_s \rightsquigarrow \type_t$) are simply a pair of monotypes (as defined in HM), $\type_s$ represent the source type and the $\type_t$ the target type of the conversion. A conversion polytype ($\convpoly=\forall \overline {\tyVar} . \overline{(j : \type_{\rightsquigarrow})} \Rightarrow \type_{\rightsquigarrow}$) specifies a set of type variables $\overline {\tyVar}$, a set of conditionals $\overline{(j : \type_{\rightsquigarrow})}$ (names bound to conversion monotypes) and a final conversion monotype $\type_{\rightsquigarrow}$. 

An implicit environment $\imEnv$ is simply a set of available implicit conversions, sometimes referred to as \textit{conversion axioms}. Intuitively, having an implicit conversion $i : \type_1 \rightsquigarrow \type_2 = \term$ in $\imEnv$ states that, under $\imEnv$, $\type_1$ is implicitly convertible to $\type_2$ and that $\term$ should be used to convert terms from $\type_1$ to $\type_2$.

Programs consist of a single type annotation (the type of the whole program), data declarations (responsible for the introduction of data and type constructors to the typing environment), and a single expression. At the moment, this type annotation is required as we perform local type inference. However, it is not a necessity of a language with implicits but rather a design choice to be discussed in Chapter \ref{cha:6}. The full syntax for TrIC is given in \fref{mlsyntax}.

\subsection{Polymorphic Conversions}
\label{polymorphic conversions}
As previously stated and deducible from the syntax, TrIC allows the programmer to write implicit conversions ($i_{conv} : \forall \overline{a}.\overline{j_i : \convmono_i} \Rightarrow \convmono = \term$) parametrized over type variables $\overline{a}$  and constrained by the conditions ($\overline{j_i : \convmono_i}$) it imposes. These are satisfied if, for each required conversion monotype $\convmono_i$, an implicit conversion of type $\convmono_i$ can be constructed from the conversion axioms in scope (\textit{i.e.} in the implicit environment).

By allowing the use of the $j_i$'s in the converting expression the user is able to write an implicit conversion that itself behaves differently in different places in the code (it behaves according to the implicits that satisfy its conditions), with the added benefit of using a single identifier to stand for a conversion expression.

For an implicit conversion with conditions $\overline{j_i : \convmono_i}$, the $\overline{j_i}$ are available for its converting expression $\term$. Each will be substituted, during compile time, by the actual converting expression of the corresponding $i_i:\convmono_i$ constructed from the implicit environment.

Parametric polymorphism by itself has limited applicability in implicit conversions: in fact it may be hard to think of a case in which implicit conversions from and/or to \textit{anything} useful. However, the two fore mentioned features have a symbiotic relation. If, for example, a list datatype is present and a mapping functions defined, we can easily write an implicit conversion from a list of any type $a$ to a list of any other type $b$ provided an implicit conversion from $a$ to $b$ is available as follows: $i_{lists}: j: a \rightsquigarrow b \Rightarrow [a] \rightsquigarrow [b] = \lambda \tmVar . map\;j\;\tmVar$

\begin{figure}
   \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  pgm ::= \type;\overline{data};\term\hfill Program\\
  data\,::= data\;T\;\tyVar=K\;\overline{\type}\hfill Data\;Declaration
  \\[5mm]
  \type ::= \tyVar\,|\,\type_1\to\type_2\,|\,T\,\overline{\type}\hfill Monotypes\\
  \typeS ::= \type\,|\,\forall\tyVar.\typeS\hfill Polytypes
  \\[5mm]
    \type_{\rightsquigarrow} ::= \type \rightsquigarrow \type\hfill Conversion\;Monotypes\\
  \typeS_{\rightsquigarrow} ::= \forall \overline {\tyVar} . \overline{(j : \type_{\rightsquigarrow})} \Rightarrow \type_{\rightsquigarrow}\hfill Conversion\;Polytypes
  \\[5mm]
  \term ::= \tmVar\;|\,\lambda \tmVar.\term\;|\,\term_1 \; \term_2\;|\, K \;|\, case \, \term_1 \, of\, (K \tmVar) \rightarrow \term_2 \hfill Terms\\
  \phantom{\term ::}|\, let \, \tmVar \, =\, \term_1 \,in\, \term_2  \;|\, locimp \; i : \typeS_{\rightsquigarrow}=\term\; in\; \term_2
  \\[5mm]
  \imEnv::=\overline{i : \typeS_{\rightsquigarrow}=\term} \hfill Implicit\;Environment
  \\[5mm]
  \tyEnv::=\bullet\,|\,\tyEnv,\tmVar:\typeS\,|\,\tyEnv,\tyVar\,|\,\tyEnv,K:\typeS\,|\,\tyEnv,T \hfill \phantom{xxxxxxxxxxxxxxx} Typing\; Environment

  \end{array}
\]
  \caption{TrIC's syntax}
  \label{mlsyntax}
\end{figure}

\section{Typing}
The top-level program typing rules are standard for languages with data types, with the exception of the rule \textsc{Type}. This rule enforces that the type of the program is in fact the same as the type $\type$ provided by the user. Program typing rules and data declaration typing are shown respectively in \fref{pgmtyping} and \fref{datadtyping}.

As for term typing, shown in \fref{termtyping}, applications and case expressions are now treated differently from HM typing. The intuition for rule TmApp is that we no longer require the type of the operand to match the left side of the (function) type of the operator, but rather that we are able to implicitly convert from the former to the latter.

Similarly, TmCase requires the weaker condition that the type of the scrutinee is convertible to the type of the pattern. Further, instead of imposing the same type to all of the alternatives, it merely imposes that all the alternatives are convertible into a common type. Unsurprisingly, this design decision results in a more powerful language since we extend the applicability of implicit conversions to another subset of the language.

According to the \textsc{TmLocImp} rule, the converting expression $\term_{conv}$ introduced by the implicit conversion ($i_{conv} : \overline{j_i : \type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_{s} \rightsquigarrow \type_{t} = \term_{conv}$) of $locimp$ must conform to $\type_{s} \to \type_{t}$, under an extended typing environment under which the $j_i$'s have type $\type_{s_i} \to \type_{t_i}$. We then type the sub-term $\term$ of $locimp$ under a implicit environment extended with the implicit conversion $i_{conv}$.

In order words, this means that we can use $i_{conv}$ in order to ``fix'' $\term$. This ``fixing'' has local scope: if $\term$ has some sub-terms whose types don't match but can be made to match by application of $impl$, then $impl$ will be used. If, however, $\term$ is a sub-term of some term $\term_{super}$ and has a type that doesn't conform to the type of $\term_{super}$, $impl$ will not be considered in order to fix the program. For that to happen, $impl$ would have to be available in a broader scope: it should be defined in a $locimp$ that has $\term_{super}$ as a subterm.

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \progTyping{\imEnv}{\tyEnv}{t\_pgm}{\type}}
                {Program Typing}
\end{flushleft}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
\inferrule*[right=Type]
           {\progTyping{\imEnv}{\tyEnv}{pgm}{\type}}
           {\progTyping{\imEnv}{\tyEnv}{\type;pgm}{\type}}
           \\[5mm]           
\inferrule*[right=Data]
           {\dataDTyping{\tyEnv}{data}{\tyEnv'}\ \\\progTyping{\imEnv}{\tyEnv'}{pgm}{\type}}
           {\progTyping{\imEnv}{\tyEnv}{data;pgm}{\type}}
           \\[5mm]           
\inferrule*[right=Expression]
           {\txTerm{\imEnv}{\tyEnv}{\term}{\type}}
           {\progTyping{\imEnv}{\tyEnv}{\term}{\type}}           
\end{array}
\]
\caption{Program Typing}
\label{pgmtyping}
\end{figure}

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \dataDTyping{\tyEnv}{data}{\tyEnv'} }
                {Data Declaration Typing}
\end{flushleft}
\[
\inferrule*[right=Decl]
           { }
           {\dataDTyping{\tyEnv}{(data\;T\;\tyVar=K\;\overline{\type})}{\tyEnv,T,(K:\tyAbs{\tyVar}{\overline{\type} \rightarrow T\;\tyVar})}}
\]
\caption{Declaration Typing}
\label{datadtyping}
\end{figure}

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \sTermTyping{\imEnv}{\tyEnv}{\term}{\typeS} }
                {Term Typing}
\end{flushleft}
%\begin{comment}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
    \inferrule*[right=Var]
             {(\tmVar : \typeS)\in\tyEnv}
             {\sTermTyping{\imEnv}{\tyEnv}{\tmVar}{\typeS}}

             \quad\quad
             
  \inferrule*[right=Constr]
             {(K:\typeS) \in \tyEnv}
             {\sTermTyping{\imEnv}{\tyEnv}{K}{\typeS}}
            \\[5mm]

  \inferrule*[right=TmApp]
  {
  \sTermTyping{\imEnv}{\tyEnv}{\term_1}{\type_{arg} \to \type_2} \\
  \sTermTyping{\imEnv}{\tyEnv}{\term_2}{\type_1}\\
  \imRes{\imEnv}{j}{\type_1}{\type_{arg}}
  }
  { \sTermTyping{\imEnv}{\tyEnv}{\term_1\, \term_2}{\type_2} }

  \\[5mm]

  \inferrule*[right=TmAbs]
  {
  \sTermTyping{\imEnv}{\tyEnv, \tmVar : \type_1}{\term}{\type_2}
  }
  { \sTermTyping{\imEnv}{\tyEnv}{\lambda \tmVar . \term}{\type_1 \to \type_2} }
  \\[5mm]

  \inferrule*[right=TmLet]
  {
  \txTerm{\imEnv}{\tyEnv}{\term_1}{\typeS} \\
  \txTerm{\imEnv}{\tyEnv,\tmVar:\typeS}{\term_2}{\type_2}
  }
  { \txTerm{\imEnv}{\tyEnv}{let\,\tmVar=\term_1\,in\,\term_2}{\type_2} }

  \\[5mm]
  \inferrule*[right=TmCase]              
             {\overline{(K_i : \forall \overline{a} . \overline{\type} \rightarrow T \;\overline{a})\in \tyEnv}
               \\
               \txTerm{\imEnv}{\tyEnv}{e_1}{\type_1}
               \\
               \overline{\txTerm{\imEnv}{\tyEnv,\overline{\tmVar_i}:[\overline{a}\mapsto \overline{c_i}]\overline{\type}}{e_i}{\type_i}}
               \\
               \imRes{\imEnv}{j_1}{\type_1}{b}\\
               \overline{\imRes{\imEnv}{j_i}{\type_i}{\type_2}}\\
               fresh\;b,\;\overline{c_i},\;d\;,j
             }
             {\txTerm{\imEnv}{\tyEnv}{case\;e_1\;of\;\overline{(K_i\;\overline{x_i})\rightarrow e_i}}{\type_2}}
             
  \\[5mm]
  \inferrule*[right=TmLocimp]
  {
  \sTermTyping{\bullet}{\tyEnv,\overline{\tyVar},\overline{j_i :\type_s \to \type_t}}{\term_1}{\type_{\rightsquigarrow}} \\
  \sTermTyping{\imEnv,i}{\tyEnv}{\term_2}{\type_2}
  }
  { \sTermTyping{\imEnv}{\tyEnv}{(\iLocal{i}{\forall \overline{\tyVar}.\overline{j_i :\type_s \rightsquigarrow \type_t} \Rightarrow\type_{\rightsquigarrow}}{\term_1}{\term_2})}{\type_2} }
 
  \\[5mm]
  \inferrule*[right=Type Application]
             {\sTermTyping{\imEnv}{\tyEnv}{\term}{\forall \tyVar. \typeS}\\
               \tyEnv \vdash_{ty} \type }
             {\sTermTyping{\imEnv}{\tyEnv}{\term}{[\tyVar \mapsto \type]\typeS} }           
  \\[5mm]
  \inferrule*[right=Type Abstraction]
             {\sTermTyping{\imEnv}{\tyEnv,\tyVar}{\term}{\typeS}}
             {\sTermTyping{\imEnv}{\tyEnv}{\term}{\forall \tyVar.\typeS} }
\end{array}
\]
\caption{TrIC's Term Typing}
\label{termtyping}
\end{figure}

\section{Constraint Generation}
\label{constraint generation}
To infer a type of a program, we first build the typing environment from the data declarations. We then traverse the final term, locally building the implicit environment as well as collecting both equality constraints (identical to HM) and the novel conversion constraints.

A conversion constraint is a pair of a conversion monotype $\type_{source} \rightsquigarrow \type_{target}$ and an implicit environment $\imEnv$. It states that, under $\imEnv$ (the implicit environment under which it was generated), it must be possible to implicitly convert from $\type_{source}$ to $\type_{target}$. This entailment process is explained in detail in chapter \ref{cha:6}.

The generated constraints are easy to understand if we keep in mind HM's generation of constraints as well as the intuition provided when explaining the typing rules. Upon encountering an application expression we generate constraints as follows: if the operator $\term_1$ has type $\type_1$ and the operand $\term_2$ type $\type_2$, we type $\term_1\;\term_2$ as having type $\tyVar$ and store an equality constraint specifying that $\type_1$ is of the form $b \to \tyVar$, for some fresh type variable $b$. We also store a conversion constraint specifying that we need to be able to implicitly convert from $\type_2$ to $b$, under the current implicit environment $\imEnv$.

Case expressions also generate constraints. The idea here is that we must be able to implicitly convert from the type of the scrutinee to (an instantiation of) the type specified by the data constructor on the patterns in the alternatives. Concretely, for a scrutinee  $\term_1$ with type $\type_1$, we store a conversion constraint from $\type_1$ to a fresh type variable $b$. Then, for each alternative, we enforce that $b$ equals the type of the pattern and that all the resulting expressions, under the typing environment extended with the patterns, have the same type. Other terms in our language merely collect the constraints of their sub-expressions.

After collecting the constraints generated by the term, we add one last equality constraint: the monotype resulting from type inference on the term must be unifiable with the monotype in the type annotation. There are two reasons why this constraint is necessary: lambda abstractions and parametric polymorphism. We discuss the former in \ref{simple5} and the latter in \ref{complex5}.

As we will see, we can always ``convert'' a type into itself, so, unsurprisingly,  this set of constraints is weaker than the constraints generated from typing HM terms: every term well-typed under HM is also well-typed under our language.


\begin{figure}
\begin{flushleft}
  \namedRuleform{ \tyInfElab{\imEnv}{\tyEnv}{\term}{\type}{\eqCts}{\imCts}{\term'}}
                {}
\end{flushleft}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
  \inferrule*[right=Var]
             {(\tmVar : \forall \overline{\tyVar}.\type)\in\tyEnv \\ \overline{b} \; fresh}
             {\tyInfElab{\imEnv}{\tyEnv}{\tmVar}{[\overline{\tyVar}\mapsto\overline{b}]\type}{\bullet}{\bullet}{\tmVar}}

             \quad\quad
             
  \inferrule*[right=Constr]
             {(K:\forall \tyVar . \type) \in \tyEnv}
             {\tyInfElab{\imEnv}{\tyEnv}{K}{[\tyVar \mapsto \type']\type}{\bullet}{\bullet}{K}}
            \\[5mm]

  \inferrule*[right=Abstraction]
             {\tyInfElab{\imEnv}{\tyEnv,\tmVar:\tyVar}{\term}{\type}{\eqCts}{\imCts}{\term'}}
             {\tyInfElab{\imEnv}{\tyEnv}{\lambda \tmVar . \term}{\tyVar \rightarrow \type}{\eqCts}{\imCts}{\term'}}

\\[5mm]
  
  \inferrule*[right=Application]
  {
  \tyInfElab{\imEnv}{\tyEnv}{\term_1}{\type_1}{\eqCts_1}{\imCts_1}{\term_1'} \\
  \tyInfElab{\imEnv}{\tyEnv}{\term_2}{\type_2}{\eqCts_2}{\imCts_2}{\term_2'}
  \\ fresh\;a\;,b\;,j
  }
  { \tyInfElab{\imEnv}{\tyEnv}{\term_1 \term_2}{\tyVar}{\eqCts_1 + \eqCts_2 + (\type_1 \sim b \rightarrow a)}{\imCts_1 +\imCts_2 + \convconst{\imEnv}{j}{\type_2}{b}}{\term_1'(j \; \term_2')} }
  
  \\[5mm]
  
  \inferrule*[right=Case]
             {\overline{(K_i : \forall \overline{a} . \overline{\type} \rightarrow T \;\overline{a})\in \tyEnv}
               \\
               \tyInfElab{\imEnv}{\tyEnv}{e_1}{\type_1}{E_1}{Y_1}{e_1'}
               \\
               \overline{\tyInfElab{\imEnv}{\tyEnv,\overline{\tmVar_i}:[\overline{a}\mapsto \overline{c_i}]\overline{\type}}{e_{2i}}{\type_i}{E_i}{Y_i}{e_{2i}'}}
               \\
               fresh\;,b\;\overline{c_i},\;d\;,j
             }
             {\tyInfElab{\imEnv}{\tyEnv}{case\;e_1\;of\;\overline{(K_i\;\overline{x})\rightarrow e_{2i}}}{d}{E}{Y}{\term'}\\
               E=E_1+\Sigma_iE_i+\overline{b \sim T\;\overline{c_i}}+\overline{\type_i \sim d}\\Y=Y_1+\Sigma_iY_i+\convconst{\imEnv}{j}{\type_1}{b}\\
               \highlight{\term' = case\;(j\;e_1')\;of\;\overline{(K_i\;\overline{\tmVar})\rightarrow e_{2i}'}}}
\\[5mm]
  
  \inferrule*[right=Let]
  {
  \tyInfElab{\imEnv}{\tyEnv}{\term_1}{\type_1}{\eqCts_1}{\imCts_1}{\term_1'} \\
  \tyInfElab{\imEnv}{\tyEnv}{\term_2}{\type_2}{\eqCts_2}{\imCts_2}{\term_2'}
  }
  { \tyInfElab{\imEnv}{\tyEnv}{let\,\tmVar=\term_1\,in\,\term_2}{\tyVar}{\eqCts_1 + \eqCts_2}{\imCts_1 +\imCts_2}{let\,\tmVar=\term_1'\,in\,\term_2'} }
  \\[5mm]
  
  \inferrule*[right=LocImp]
  {
  \elabTerm{\bullet}{\tyEnv,\overline{\tyVar},\overline{j_i :\type_{source}\to\type_{target}}}{\term_1}{\type_{\rightsquigarrow}}{\term_1'}\\
  \tyInfElab{\imEnv,i}{\tyEnv}{\term_2}{\type}{\eqCts}{\imCts}{\term_2'}
  }
  { \tyInfElab{\imEnv}{\tyEnv}{(\iLocal{i}{\forall \overline{\tyVar}.\overline{j_i :\type_{source}\to\type_{target}}\Rightarrow\type_{\rightsquigarrow}}{\term_1}{\term_2})}{\type}{\eqCts}{\imCts}{\term_2'}}
  
\end{array}
\]
\caption{Type Inference and Partial Translation}
\label{typeinf}
\end{figure}

\section{Example}
We will now present two example programs in TrIC. Besides showcasing the syntax, they will illustrate the collection of constraints.
\subsection{A Simple Example}


The first program, in \fref{simple5}, defines three data types, a simple implicit conversion and a final term in conspicuous need of that implicit conversion. All implicits that appear in the program before any term can be considered as having a ``global'' scope (since they can be used anywhere in the program). This is the case for the implicit $i$.

To collect the constraints we perform the inference algorithm, as described in \fref{typeinf}. Declarations construct the typing environment, without generating any constraint. The expression of the program, it is a $locimpl$ term: its first part introduces a new implicit conversion into the implicit environment $\imEnv$; its second is an application.

Both subterms of the application are elaborated without generating constraints. The application itself generates one equality constraint ($TyB \to TyC \sim b \to a$) and one conversion constraint: $\convconst{\imEnv}{j}{TyA}{b}$. Another equality constraint is generated from the type annotation: $a \sim TyC$.

The equality constraint where the type annotation is present enables type inference for lambda abstractions. Suppose there is no type annotation and that, in \fref{simple5}, instead of ``$C\;A$'' we have ``$\lambda x. C \;x$''. Intuitively, we would want to type it as ``$\tyVar \to TyC$, provided that $\tyVar$ can be implicitly converted to $TyC$''.

In order to avoid such more complex ``types'', we take the type annotation into account: the annotation forces the instantiation of $\tyVar$ to a concrete type, for which we can decide if there is the required implicit conversion and hence whether or not the program is well-typed.
\begin{figure}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;TyA=A1\;|\;A2;\\
  data\;TyB=B;\\
  data\;TyC=C\;TyB\\[3mm]
  \monolocal{i}{TyA}{TyB}{\lambda \tmVar . B}{C\;A}\\
  :*: TyC
\end{array}
\]
\caption{A TrIC program}
\label{simple5}
\end{figure}
\subsection{A More Involved Example}
The program in \fref{complex5} is a bit more complex: it defines five data types, one of which contains type variables and five local implicit conversions, one of which with a restricted scope.

As before (as always, by design), neither data declarations nor the declarations of implicit conversions in the first part of $locimp$ terms generate constraints. We then reach a term that is an application of an ordinary term (another application $W\;B$) to a $locimp$ term.

In order to elaborate and generate the constraints from the top-level application we must first do so for its subterms. The left hand side  $W\;B$ generates one equality and one conversion constraint. The right hand side of the top-level application is the same term as presented in \fref{simple5}, so it generates similar constraints, but under a new implicit environment.

Note that, due to being the second part of a $locimp$ term, the constraints generated by $C\;A$ specify a richer implicit environment ($\imEnv_2$) than any of the other constraints of the program (generated under $\imEnv_1$).

The top-level application generates another equality and conversion constraints, resulting in the set of equality constraints being \{$a \to a \to (TyW \; a) \sim b_1 \to b_2$ ,$TyB \to TyC \sim b_3 \to b_4$, $b_2 \sim b_5 \to b_6$\} and in the set of conversion constraints \{$\convconst{\imEnv_1}{j_1}{TyB}{b_1}$, $\convconst{\imEnv_2}{j_2}{TyA}{b_3}$, $\convconst{\imEnv_1}{j_3}{b_4}{b_5}$ \}. We then store another constraint resulting from the user-given type: \{$TyW \; TyA \sim b_6$\}.

It should be noted that the type annotation also enables to elaborate programs that would otherwise be considered ambiguous due to polymorphic functions/data constructors (only the latter is present in TrIC, but the former will be considered in \ref{cha:7}).

This program would still be well-type in TrIC without the type annotation (but its type would then be $TyW \; TyA$. However, a minor modification to the program to include an implicit conversion from $TyC$ to $TyA$ would cause this program to be rejected if we did not annotate it. We discuss this in \ref{dominator}.


\begin{figure}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;TyA=A1\;|\;A2;\\
  data\;TyB=B;\\
  data\;TyC=C \; TyB;\\
  data\;TyD=D;\\
  data\;TyW\;\tyVar=W \tyVar \; \tyVar;\\[3mm]
  \monolocal{i_1}{TyC}{TyD}{\lambda \tmVar . D}\\
  \monolocal{i_2}{TyB}{TyD}{\lambda \tmVar . D}\\
  \monolocal{i_3}{TyD}{TyA}{\lambda \tmVar . A2}\\
  locimp\;i_4 :\forall a, b . j : a \rightsquigarrow b \Rightarrow TyW\;a\rightsquigarrow TyW\;b=\\
  \phantom{xx}\lambda \tmVar. case\;\tmVar\; of\;W\;x_1\;x_2 \to W (j\;x_1)\;(j\;x_2)\;in \\
  W\;B\;(\monolocal{i_l}{TyA}{TyB}{\lambda \tmVar.B} C\;A1)
  \\
  :*: TyW \; TyA
\end{array}
\]
\caption{A more complex TrIC program}
\label{complex5}
\end{figure}

\section{Elaboration into System F}
Our goal is to elaborate this language into System F. Afterwards we could use any existing System F compiler to optimize and translate our program into machine code for it to be run, but that is out of the scope of this thesis.

This means that we must use the converting expressions to effectively transform an ill-typed program into a (well-typed) System F term.

Note that conversion constraints specify conversion monotypes (pairs of types such that the first needs to be convertible into the second); these constraints are relations between the types of subterms of applications or subterms of case expressions. In addition, the implicit environment is a set of pairs of a conversion type (again a relation between types) and a System F expression capable of converting from the source type to the target type.

What we have to do, then, is to introduce place-holding terms in the program to act as a bridge between the fore mentioned subterms when we generate a constraint. We then keep track of this pairing of place holders and constraints, match the conversion types of the constraints with those of the implicit environment and substitute the place holding variable by the corresponding System F term.

This elaboration happens in two phases: first we elaborate declarations (in a standard way) and \textit{partially elaborate} the program's term. We then solve the constraints (\textit{i.e} match `` wanteds with the givens'') get expressions and substitute the place holders by the necessary expressions.

Partially elaborating a term implies the partial elaboration all of its subterms, as is show highlighted in \fref{typeinf}. We can see that in an application $\term_1 \term_2$ a place holding variable $j$ is put between the partially elaborated operator $\term_1'$ and operand $\term_2'$. This variable $j$ will later be substituted for a System F term capable of converting the operand into a term of the type expected by the operator. This term will be a lambda abstraction, whose type is a function type from the type of the operand to the type expected by the operator. In case the types already match, it will simply be substituted by the identity function.

Similarly, for case expressions $case\;e_1\;of\;\overline{(K_i\;\overline{x})\rightarrow e_{2i}}$, place-holders will be put to the left of the scrutinee and of the terms returned from the alternatives so that they can be later replaced by the needed conversions. For other terms, their partial elaboration is a standard HM to System F translation.

As an example \fref{partialElab} presents the partial elaboration of the program from \fref{complex5}.

\begin{figure}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;TyA=A;\\
  data\;TyB=B;\\
  data\;TyC=C \; TyB;\\
  data\;TyD=D;\\
  data\;TyW\;\tyVar=W \tyVar \; \tyVar;\\[3mm]
  (W\;(j_1\;B)) (j_3 \; (C\;(j_2\;A)))

\end{array}
\]
\caption{The partial elaboration of the more complex TrIC program}
\label{partialElab}
\end{figure}
