\chapter{Type Classes}
\label{cha:7}
We now present how this language can be extended with type classes so as to make it closer to Haskell.
\section{Syntax and Typing}
\subsection{Syntax}
In order to support type classes, some significant extensions to the syntax are necessary. We begin by introducing class and instance declarations.
\subsection{Typing}
\section{Collecting Constraints}
\section{Solving the Constraints}
A first design decision was to solve the class constraints after the equality and conversion constraints. This simplifies the solving process and isolates different features of the language.

On the flip side, this will cause us to reject some programs that could, due to their class constraints, only be fixed in one way. Because these constraints are invisible to our conversion constraint solver, it may find the conversion constraints ambiguous and as such reject the program.

As an example, suppose we have implicit conversions from EUR to Kwanzas and to Pound, and from CHF also to Kwanzas and to Pound. *write the example in code*

