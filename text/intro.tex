\chapter{Introduction}
\label{cha:intro}
We build tools to make our life easier. The goal is to have the least amount of work when solving some problem, provided that we retain full control on how our problem is being solved. Washing machines wash our dirty laundry but we choose the temperature, we don't let them guess it. However, had we a proof the machines can infer the right temperature by the laundry it has been fed, we would be glad that it is now easier to have clean clothes.

Programming languages are tools. They have been evolving for the past decades allowing us to solve more problems and/or solve them in a better way. By this we don't simply mean a more elegant final solution: the process of writing the code should be taken into account. Languages with static typing allow the detection of erroneous code sooner, at compile-time. However, static typing can lead to a reduction in the expressivity of a language and to the need of explicitly writing the types in the programs.

The Hindley-Milner type system is a perfect example of a breakthrough in the way we solve our problems. While being an powerful enough language in which we can express a great variety of programs, its advantages (over less sophisticated typed languages like the Simply Typed Lambda Calculus) are two-fold: there is no longer the need for explicitly annotating the programs and it achieves code re-use by allowing functions to be defined once and applicable to arguments of any type.

Implicit programming mechanisms ``infer values by a type-directed resolution process, making programs more compact and easier to read''(\cite{cochis}). Implicit programming features have surfaced in a number of languages: Haskell, Scala, Agda and Rust, to name a few. 

Scala is a widely used programming language that enables the use of implicit parameters and implicit conversions. This means that we can omit certain parameters to a function and scala will fetch the missing ones (under certain conditions) and that we can even apply functions to arguments of a different type, as long as there is an implicit conversion from the type of the provided argument to the type of the expected argument. As an example, we can define once an implicit conversion from the type Euro to the type Dollar, and rest assured our program will behave as expected in cases where euros are provided but dollars are expected.

Nonetheless, there is room for improvement: as the technology stands now, given an implicit conversion from Euro to Dollar and one from Dollar to Pounds, Scala's implicit conversions won't be able to take the two steps and implicitly convert from Euro to Pound. We propose a language that supports transitivity in its implicit type conversions, thus allowing the programmer to avoid writing tedious conversions and thus also possibly avoiding some hard to find bugs.

Further, we take user-friendliness into account and make sure our extension behaves in a way the user can easily predict. This is not currently the case: it is easy to provide examples of implicit conversions in Scala leading the execution of our program down intended paths.

We will provide a prototype implementation of this feature in the KU Leuven Haskell compiler. As a consequence, our extension must be compatible with the existing features, in particular with Haskell's type inference mechanism and its type classes.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
