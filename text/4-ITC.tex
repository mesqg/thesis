\chapter{Implicit Type Conversions}
\label{cha:4}
Implicit type conversions are an implicit programming feature that allows the programmer to write conversions and then have them automatically where needed. This chapter starts by introducing this feature and showcasing it with a simple example (\ref{itc4}). Afterwards, the state of the art is discussed in section \ref{scala}. In \ref{problem}, the problem statement of this thesis is precisely defined and its main ideas clarified. Finally, in \ref{ambiguity} and \ref{complex types}, some immediate consequences of the problem statement are addressed.

\section{The Basics}
\label{itc4}
In order to support implicit conversions we need two basic aspects: a set of expressions intended to be used to convert between two specified types and a way to figure out, throughout the source program, where, which and how these expressions should be inserted.

A \textit{conversion axiom} consists of one such converting expression, the type $\type_s$ it converts from and the type $\type_t$ it converts to. Even though $\type_s$ and $\type_t$ could be inferred in a language with type inference (as the one presented in chapter \ref{cha:5}), this inferred types could be more general then intended by the programmer and thus applicable in undesired circumstances. The set of conversion axioms is know as \textit{implicit environment}.

As for the ``where, which and how'' to use these conversing expressions, the main idea is to perform type inference and, upon encountering an inconsistency (we will only attempt to correct inconsistencies in applications, between the type of the operator and of the operand, and in \textsc{case} expressions, as discussed in chapter \ref{cha:5}), flag it and state type $\type_1$ inferred and the type $\type_2$ needed. Throughout this text we call this a \textit{conversion constraint}. 

From this point onwards, ``$\rightsquigarrow$'' will be used to denote the implicit conversion from the type $\type_s$ on its left to the type $\type_t$ on its right, as in  $\type_s \rightsquigarrow \type_t$. In this chapter, to distinguish between the possibility of converting from $\type_s$ to $\type_t$ (due to the existent conversion axioms) and the necessity of a conversion again from $\type_s$ to $\type_t$ (a conversion constraint), these arrows will be indexed by, respectively, ``ax'' ($\type_s\rightsquigarrow_{ax}\type_t$) and ``ct'' ($\type_s\rightsquigarrow_{ct}\type_t$).

 As a running example, suppose Maria sells olives in Lisbon. She wrote some accounting software in a statically typed language and has defined a type $EUR$. She then decides to export her olives to Switzerland, so defines a type $CHF$. If the programming language supports ITC, instead of duplicating her code or manually introducing a converting function every time a value in CHF is introduced to the system, she will only need to define once an implicit conversion from CFH to EUR to have the software running seamlessly.

As a more concrete example, consider Maria's updated program to compute the taxes she has to pay:
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
data\;EUR=K_{EUR}\;Float\\
data\;CHF=K_{CHF}\;Float\\
...\\
f:: CHF \rightsquigarrow_{ax} EUR = ... \\
taxes :: EUR \to EUR = ...\\
taxes (K_{CHF} \; 300)
\end{array}
\]
 Implicit conversions would elaborate the final expression to $taxes (f\;(K_{CHF} \; 300))$, which could then be evaluated to a $EUR$ value.

% Suppose also that Maria travells back and forth in her electrical truck, only accepts cash payments in the local currency and can't cross countries with foreign currency.
\section{TODO.Scala}
\label{scala}
, by considering this feature in Scala (a widely used programming language)
Scala is a widely used language with support for Implicit Type Conversions. In Scala, a programmer is free to mark declarations with the ``implicit'' keyword. These declarations can later be used to fix type errors.

Scala claims that it will not attempt to insert implicit conversions if there is not need for them and tries a single implicit at a time, \textit{i.e.} it will not try to compose conversions in order to fix type errors.

To be available for use, an implicit conversion must be in scope under a single identifier (\textit{ i.e.} iconv but not X.iconv) or be defined in the ``companion object of  the source or expected target types of the conversion''.

Scala enforces a ``non-ambiguity rule'': if two converting options are possible, an error will be reported. TODO because we found counter examples?

(mention conversions of the receiver of a selection?)
scala.Predef
The use of implicit parameters enables writing an implicit conversion only applicable when another is in scope. It also allows for polymorphic methods in general, and in particular polymorphic implicit conversions.

We could be tempted to use these feature in order to write a rule that would introduce transitivity. We would write as `` an implicit can be used to convert type variable $a$ to type variable $c$ if there are two implicit parameters: one able to convert from $a$ to another type variable $b$ and a second capable of converting from $b$ to $c$. However, this is not supported in Scala: there can only be one implicit parameter.
\section{Problem Statement}
\label{problem}
The aim of this thesis is to design a calculus with implicit type conversions that can be adapted to extend the KU Leuven Haskell Compiler (KHC) with this feature. This calculus improves on the state of the art by allowing transitivity to be used in hte implicit type conversions. Other novelties are the local scoping of the conversion axioms and the fact that the user is able to write axioms that are only applicable if (possibly multiple) conditions on the implicit environment are met. 

Since it is designed with the prospect of extending the KHC, type inference, the compatibility of the calculus with type classes and (ease of) predictability are central concerns.

In this section, we elaborate on the advanced features supported by the implicit conversions in the calculus.

\subsection{Transitivity}
Supporting transitivity in implicit type conversions means that the language automatically tries to compose the available conversion axioms in order to convert a term to the appropriate type.

In spite of the benefits of this approach being self evident, consider the following example. Suppose Maria now also sells olives in Copenhagen. She now also has to deal with Danish Krones (DKK). For reasons only she understands, she needs to use call functions expecting CHF with arguments of type DKK. As before, much of the code is writen for arguments to be of type EUR and as such she also needs a convertion from DKK to EUR. Having defined a conversion from CHF to EUR before, she now need only to define an implicit conversion from DKK to CHK and she gets an implicit conversion from DKK to EUR for free. 

This is clearly a useful feature that allows the programmer to write less conversions. In general, if she needs defines a chain of $n$ conversions she will get $(n^2-n)/2$ converting functions for free.

As you might expect this feature does not come without costs. In \ref{ambiguity} we discuss how the presence of transitivity has a multipling effect in the number of ways a source program can be corrected.


\subsection{Local Scoping}
The language presented in this thesis enables a variable implicit environment throughout the code. Allowing the programmer to write locally scoped conversion axioms enables her to retain full control of the code while providing the convenience of implicit conversions. 

Adjusting the implicit environment has much more profound consequences than just altering the set of typable terms: it determines the types of the terms (and thus which conversion axioms should be used to correct a program) and makes it possible for conflicting conversions to co-exist in the code, as long has their scope does not overlap. As a corollary of this, the same function, applied to the same argument can yield different results due to that fact that different conversions are being used in distinct parts of the code, as intended by the programmer.

As an example of how the implicit environment affects the value of some expression, suppose a complex function \textit{happiness} that computes the happiness of Maria by taking two arguments: the money (in CHF) she has and her location (the name of a city, from a pre determined set of cities). Given these two, the function proceeds by case analysis on the location. Depending on the city she is at, it calls a myriad of functions, some of which require EUR as input. Suppose the converting function CHF to EUR also depends on which city Maria is (\textit{i.e.} the exchange rate of CHF to EUR is higher in Zurich than in Lugano). This program can be simplified by writing conversion axioms whose scope is restricted to the part of \textit{happiness} that implements the behavior for each city.

%Take for example a function that determines whether someone is rich by comparing their net worth against an established cutoff value in Euros. By defining multiple (implicit) converting functions from CHF to Euro, Maria (in Switzerland with her CHF) can be poor in one scenario but rich in a part of the code that deals with the eventuality of the increase of counterfeit euro notes.

As will be shown in \ref{ambiguity}, the implicit environment takes an absolutely central role in the language, inclusively determining to which types some terms need to convert into, affecting the elaboration of the terms and the results of the program.

\subsection{Parametric Polymorphism and Constrained Conversions}
Parametric polymorphism enables great code re-use. It has proven to be a very useful programming feature, with widespread support by programming languages. Allowing it in the definition of implicit conversions brings those same benefits to this extension of the language.

By constrained conversion we mean a conversion axiom $ax$ that can only be used if some conditions regarding the existence of other conversion axioms in the implicit environment are met. These feature is particularly useful since the expressions in the (axioms in the) conditions are available to be used in the converting expression introduced by $ax$.

Parametric polymorphism by itself has limited applicability in implicit conversions: in fact it may be hard to think of a case in which implicit conversions from and/or to \textit{anything} useful. However, the two fore mentioned features have a symbiotic relation. If, for example, a list datatype is present and a mapping functions defined, we can easily write an implicit conversion from a list of any type $a$ to a list of any other type $b$ provided a conversion axiom $ax$ from $a$ to $b$ is available using an identifier to stand for $ax$ in the converting expression from list of $a$ to list of $b$. This feature is further discussed in \ref{polymorphic conversions}.



\section{Ambiguity}
\label{ambiguity}
Implicit type conversions are, in essence, a language feature that automatically corrects (typing) errors. For languages with such a features, an immediate concern is to specify its behavior when there are multiple ways to correct the source program. 

Consider now the following program:
\[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
data\;\text{EUR}=K_{\text{EUR}}\;Float\\
data\;\text{CHF}=K_{\text{CHF}}\;Float\\
data\;\text{DKK}=K_{\text{DKK}}\;Float\\
data\;\text{USD}=K_{\text{USD}}\;Float\\
data\;\text{Wallet}\;a = K_{\text{Wallet}} \;a \;a\\[3mm]
K_{\text{Wallet}}\;(K_{\text{DKK}}\;10)\;(K_{\text{CHF}}\;30)
\end{array}
\]

Assume the existence of the following implicit conversions: DKK $\rightsquigarrow_{ax}$ EUR and CHF $\rightsquigarrow_{ax}$ EUR. It is clear from this example that there are decisions to be made before we start composing the conversions to convert from some ground type to another. What should we convert ``$K_{\text{DKK}}\;10$'' and ``$K_{\text{CHF}}\;30$'' into, so that this program is well typed? This is an easy decision: both should be converted into $EUR$.

If, in addition to the implicit conversions already defined, we also had and $DKK \rightsquigarrow_{ax} USD$ and $CHF \rightsquigarrow_{ax} USD$, the same choice would now be arbitrary: both $EUR$ and $USD$ are possible and there is no obvious criteria under which one is better than the other.

For a more intricate case, suppose the implicit conversions defined are: $DKK\rightsquigarrow_{ax}EUR$, $CHF\rightsquigarrow_{ax}EUR$ and $EUR \rightsquigarrow_{ax} USD$. Despite being still possible to convert both $DKK$ and $CHF$ to both $EUR$ and $USD$, a case could be made that program should be corrected (by converting both to $EUR$) rather than rejected: both $DKK$ and $CHF$ need to be converted to $EUR$ before they can then be converted to $USD$. Finally, how to proceed if there is a fourth conversion, from $DKK$ to $USD$?

Another decision is what should the behavior of the language be when there are multiple ways to convert between two (ground) types. Suppose we must convert from $DKK$ to $EUR$ and there are available two applicable conversion axioms: $DKK \rightsquigarrow_{ax} EUR$ and $a \rightsquigarrow_{ax} EUR$. Or suppose there are three axioms, the first two of which can be composed (due transitivity), to convert from $DKK$ to $EUR$: $DKK \rightsquigarrow_{ax} USD$, $EUR$: $USD \rightsquigarrow_{ax} EUR$, and $DKK \rightsquigarrow_{ax} EUR$.

We must define the behavior of the language for all the above cases clearly and exhaustively. Since predictability is a crucial requirement of any programming language, a first step is not allowing any arbitrary choices. This is achieved by defining ambiguity in the context of the language and by rejecting programs deemed ambiguous.

When it comes to choosing a definition for ambiguity, there is a natural tension between simplicity and expressivity. A finer-grained definition places more of a burden on the user in order to understand the functioning of implicit conversions, while a blunter one maims the expressivity of the language. One other aspect to keep in mind is that, as just illustrated, both parametric polymorphism and transitivity lead to a broader applicability of user-defined conversions. As a consequence, the chances that there are several ways to correct a program are higher.

First and foremost, choosing to which type $\type_t$ a term should be converted into should be distinguished from multiple conversions being possible from one ground type to another.

Regarding conversions between two ground types, we consider it to be ambiguous if there are multiple ways in which to compose the axioms to form said conversion. Furthermore, if any of the axioms has conditions that can be entailed in more than one ways, we consider the program ambiguous.

(we have considered other approaches that can lead to interesting future work: assigning costs to each defined conversion and choose the converting path with the least associated cost is an example.)

As for deciding to what type $\type_t$ some given types $\overline{\type_{s_i}}$ should convert into, a first obvious approach would be to reject any program in which any choices are possible. However, this would mean the program presented in this section, with $DKK\rightsquigarrow_{ax}EUR$, $CHF\rightsquigarrow_{ax}EUR$ and $EUR \rightsquigarrow_{ax} USD$ as available implicits would be rejected. In order to avoid this severe and unnecessary restriction, we rely on the definition of dominator (\ref{dom4}) and consider the program ambiguous when, for at least one case, no dominator exists.

%A program is also considered ambiguous (and thus is rejected by the language presented in \ref{cha:5}) if the instantiation of its type variables is ambiguous or, if any of its ground conversion constraints is ambiguous.

\subsection{Dominator}
\label{dom4}
The notion of \textit{dominator} was introduced as an answer to the question ``to what type should some terms be implicitly converted to?''. This question rises under a set of conversion constraints (from the source program) and its answer is computed with respect to the set of conversion axioms available in that setting.

The \textit{dominator} of a set of conversion constraints $S=\overline{\type_{s_i}\rightsquigarrow \type_{t_i}}$, with $\overline{\type_{s_i}}$ ground types, is defined as being the type $\type_{dominator}$ to which all $\type_i$'s can convert into and that, for any other type $\type_d$ such that  all $\type_i$'s can convert into $\type_d$, any conversion from any $\type_i$ to $\type_d$ can be decomposed into a conversion from $\type_i$ to $\type_{dominator}$ and another from $\type_{dominator}$ to $\type_d$ We assume there is always a conversion from a type to itself.

The generation of constraints will be discussed in detail in \ref{constraint generation}. Nonetheless, we can already use the intuition to infer that the conversion constraints generated under the program presented in this section are ``$DKK\rightsquigarrow_{ct} a_1$'' and ``$CHF\rightsquigarrow_{ct} a_1$'', for some (the same in both cases) type variable $a_1$. For ease of visualization, \fref{dom4pic} plots in a graph multiple sets the conversion axioms under which the dominator of these two constraints is computed.
\begin{figure}
  \centering
  \includegraphics[height=25mm]{dom4pic}
  \caption[]{Possibilities for Conversion Axioms}
  \label{dom4pic}
\end{figure}

The first set of conversion axioms discussed in this section is \{$ax_1,ax_2$\}. Since there is only one type into which both DKK and CHF are convertible when these are the available axioms, EUR, the dominator is EUR.

If we now extend the set of available axioms to \{$ax_1,ax_2,ax_3$\}, both DKK and CHF are convertible to both EUR and USD. However, (all) the conversion(s) from DKK to USD can be decomposed into a conversion from DKK to EUR an another from EUR to USD and like wise from CHF to USD, so EUR is the dominator of the constraints, reflecting the intended behavior.

Extending the implicit environment to \{$ax_1,ax_2,ax_3,ax_4$\} does not affect the set of types both CHF and DKK can convert in to, so it does not affect the dominator(it is still EUR). Under the assumption that the implicit environment is \{$ax_1,ax_2,ax_3,ax_5$\}, there is once again a single type both CHF and DKK can convert into: USD. As such, USD is the dominator.

Finally, if we consider all the axioms in \fref{dom4pic}, no dominator exists and, as a consequence we reject the program. In this setting, both EUR and USD are reachable from both CHF and DKK. USD is clearly not the dominator as $ax_1$ is a conversion from CHF to EUR that can not be decomposed into a conversion from CHF to USD and a conversion from USD to EUR; neither is EUR: the composition of axioms $ax_4$ and $ax_5$ is a conversion from DKK into USD that can not be decomposed into a conversion from DKK to EUR and a conversion from EUR to USD.

%ZWD  \\   USD\\  $\rightsquigarrow_{ax_1}$\\$\rightsquigarrow_{ax_2}$\\$\rightsquigarrow_{ax_3}$\\$\rightsquigarrow_{ax_4}$\\$\rightsquigarrow_{ax_5}$

%\subsection{Conditionals}
%\textbf{local type inference => how to use unresolved type variables?? Okay constraints wont have them but while constructing the conversion...}
\section{Complex Types}
\label{complex types}
Consider again the data type Wallet $a$, whose constructor \textsc{$K_{\text{Wallet}} \;a \; a$} takes two terms of type $a$. In the last section we discussed the term \textsc{$K_{\text{Wallet}}\;(K_{\text{DKK}}\;10)\;(K_{\text{CHF}}\;30)$}. Under the implicit environments presented during the discussion of dominator, this term was either ill-typed or had type Wallet EUR or Wallet USD.

If we now consider the slightly modified term \textsc{$\lambda x. (K_{\text{Wallet}}\;(K_{\text{DKK}}\;10)\;x)$} the situation changes dramatically. Under HM its type would be DKK $\to$ Wallet, which in clearly too restrictive this setting.

Having understood the idea behind implicit type conversions, we could be inclined to type \textsc{$\lambda x. (K_{\text{Wallet}}\;(K_{\text{DKK}}\;10)\;x)$} as ``$a \to$ Wallet DKK, as long as $a$ can be implicitly converted to DKK''. A second though about this would lead to the realization that this too is overly restrictive: in \ref{dom4} we have seen that, depending on the implicit environment we may convert both subterms to some common type. We have now gotten a better intuition about the type of \textsc{$\lambda x. (K_{\text{Wallet}}\;(K_{\text{DKK}}\;10)\;x)$}: it should be something like ``$a \to$ Wallet $b$, as long as both $a$ and DKK can be implicitly converted into $b$''. As programs grow, this would potent ally lead to unreasonably complex terms for the user. This will be discussed in detail in chapter \ref{cha:5}.

%Suppose the source program is simply a function that take an argument and applies it twice to the wallet constructor: $\lambda x. W_k \;x\; x$. Without implicit type conversions, this program would have type $EUR \to Wallet$. However, in a setting with implicit type conversions we must be more flexible: for any type $\type$ implicitly convertible to $EUR$, 
%It should be noted that the type annotation also enables to elaborate programs that would otherwise be considered ambiguous due to polymorphic functions/data constructors.

%Suppose there is polymorphic (on $a$) data type $Wallet \;a = W_K \;a \; a$ whose constructor takes two terms type $a$. You can think of the terms as the monetary value of the coins and of the notes, and of the type as the currency in which these values are expressed. $Wallet\;EUR$ consists of two EUR values, the EUR value of the coins and the EUR value of the notes. At this point you could have wallets of anything, not just currency. In \ref{cha:7} we discuss implicit type conversions with type classes, which would be nice here. (TODO obvsly)

%However, if Maria tries to create a wallet $(W_k (EUR_k 5) (CHF_k 70))$, in a setting in which is possible to implicitly convert from EUR to CHF and the other way around, the program can not be unambiguously elaborated. The presence of the type annotation resolves this ambiguity and we're good.
