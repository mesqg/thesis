\chapter{Constraint Solving}
\label{cha:6}

In chapter \ref{cha:5} we discussed the collection of the constraints generated by a TrIC program as well as its partial elaboration into System F. It remains to be assessed if these constraints are entailable. If so, we must complete the elaboration by substituting the place-holding variables by the appropriate converting expressions. If not, or if the source program can be elaborated in multiple ways, we must reject it.

In this chapter, we discuss the approach to check the entailability of the constraints (involving a graph-based solver) in conformity with the local type inference specified by TrIC. The detection of ambiguous programs, and the strategy to compute the converting expressions to be inserted in the code are also addressed. We end the chapter with an example showcasing constraint solving from top to bottom and the full elaboration into System F.


\section{Instantiating Type Variables}
\label{sc:cc}
The first step towards solving the equality constraints $E$ and the conversion constraints $Y$ collected in chapter \ref{cha:5} is to perform unification on the equality constraints $E$. Unless this process fails, in which case we immediately reject the program, it yields the type substitution $\Theta$ necessary to entail the equality constraints. We have moved towards solving all the constraints: now we only need to entail the $\Theta\; Y$, \textit{i.e.} the original conversion constraints $Y$ to which the type substitution $\Theta$ has been applied.
\subsection{Motivating Example}
Take for example the program presented in \fref{complex5}. We will ignore for now the constraint with the annotated type for the sake of exposing corner cases for solving the generated constraints without resorting to overly complex programs.

After solving the equality constraints and applying the type substitution to conversion constraints, these become: \{$\convconst{\imEnv_1}{j_1}{TyB}{a}$, $\convconst{\imEnv_2}{j_2}{TyA}{TyB}$, $\convconst{\imEnv_1}{j_3}{TyC}{a}$ \}.

If we were to take the conversions sequentially we would either substitute $a$ by $TyB$ or by $TyC$, depending on which we consider first. Both these constraints were generated under the same environment $\imEnv_1 = \{i_1 : TyC \rightsquigarrow TyD, \;i_2 : TyB \rightsquigarrow TyD,\; i_3 : TyD \rightsquigarrow TyA,\;i_4 :\forall a, b . j : a \rightsquigarrow b \Rightarrow TyW\;a\rightsquigarrow TyW\;b\}$. However, it is clear that we are not able to convert $TyB$ to $TyC$ nor the other way around under $\imEnv_1$, so we would be tempted to reject this program.

Nonetheless, note that we can implicitly convert from both $TyB$ and $TyC$ to $TyD$ (by using, respectively $i_2$ and $i_1$) and to $TyA$ (by using, respectively $i_3 \circ i_2$ and $i_3 \circ i_1$). So a first concern is to make sure the constraint entailment process takes multiple constraints into account and finds these suitable types to substitute $a$ with.

A second concern is how to choose a type when multiple are possible. We want TrIC to be user-friendly, so we immediately discard any sort of arbitrary choice. We must choose ``the best type'' to substitute any type variable with and reject the program if we are unable to decide. We have now move the problem to defining ``the best'' type.

Our approach is to choose the \textit{dominator} (a concept to be defined in \ref{dominator}) of the multiple possibilities. Another interesting approach would have been to assign costs to each conversion and choosing the implicit conversion with the lowest cost. These costs could be the sum, over the conversion axioms used to compose the conversion, of a function $f$ that assigns a cost to each conversion axiom. Some candidate $f$ functions are the function constantly equal to $1$ (this would mean choosing the conversion that uses less conversion axioms) or equal to a value assigned by the user when introducing an conversion axiom in the program, enabling the user to penalize some less desirable conversions.

We develop through this section a graph-based constraint solver that supports the local type inference described in our language. It considers multiple conversions when in order to instantiate a type variable and accepts programs as long as there is always a best type to substitute a type variable with, according to our definition of best (given in \ref{dominator}).

\subsection{Building the Graph}
\label{graph}
After applying the substitutions resulting from unification on the equality constraints to the conversion constraints, our goal is to substitute the remaining type variables by ground types. We plot the constraints $\overline{\convconst{\imEnv_i}{j_i}{\type_{s_i}}{\type_{t_i}}}$ with remaining type variables in a graph, with nodes for each monotype and directed edges representing the need to convert from $\type_{s_i}$ to the other $\type_{t_i}$. Note that these edges are indexed by the implicit environments $\imEnv_i$ specified by each constraint, and it may be the case that multiple edges with the same direction exist between the same types.

To construct the graph, we start by picking a conversion constraint and, if it contains type variables, create two nodes with the types present in the conversion monotype and join them by a directed edge indexed by the implicit environment $I_i$. We then pick the next $\convconst{\imEnv_i}{j_i}{\type_{s_i}}{\type_{t_i}}$ and, if $\type_{s_i}$ or $\type_{s_i}$ is a type variable already in the graph, build the edges from there.

Upon encountering a constraint $\convconst{\imEnv_i}{j_i}{\type_{s_i}}{\type_{t_i}}$ such that either $\type_{s_i}$ or $\type_{t_i}$ contains but is not a type variable $a$ already in the graph, we sort the components in the graph according to a partial order to determine which to address first. Whenever  $\type_s$ contains $a$, its component should be handled after the one that contains $a$. If $a$ is a variable of $\type_t$, this constraint should be taken into account when instantiating $a$, as discussed in \ref{dominator}. 

For each component, we know that its sources are ground types. Type variables in the sources of the first components to be handled could only occur due to top-level lambda abstractions. Solving the equality constraint involving the annotated type ensures their replacement by ground types. Type variables in the sources of other components are substituted by ground types before considering that component due to the partial order enforced.

Starting from the sources, we follow the edges of the graph. Upon encountering a type variable $a$ (necessarily as the second part of the conversion monotype), we collect all the constraints that contain $a$ in the second part of their conversion monotypes. We then proceed to find the \textit{dominator} (\ref{dominator}) on this set of conversion constraints, substitute $a$ by the dominator (a ground type) everywhere and carry on following the edges.

\subsection{The Dominator}
\label{dominator}
The \textit{dominator}, of a set of conversion constraints $S=\overline{\convconst{\imEnv_i}{j_i}{\type_{s_i}}{a}}$, with $\overline{\type_{s_i}}$ ground types, is the type $\type_{dominator}$ to which all $\type_i$'s can convert into and that, for any other type $\type_d$ such that  all $\type_i$'s can convert into $\type_d$, any conversion from any $\type_i$ to $\type_d$ can be decomposed into a conversion from $\type_i$ to $\type_{dominator}$ and another from $\type_{dominator}$ to $\type_d$.

To formalize this notion of being able to implicitly convert, we now introduce two judgments: one (\textsc{Theorem Conversion Judgment}) specifies the existence of an implicit conversion between two types; the other (\textsc{Axiom Conversion Judgment}) is stronger as it states that only one conversion axiom is needed to implicitly convert from the source type to the target type.


\subsubsection{Conversion Judgments}
\label{susec}
The axiom conversion judgment ($\convax{\imEnv}{j}{\type_1}{\type_2}$), formalized in \fref{ICJ} states that there is a conversion axiom in $\imEnv$ that can be used to implicitly convert from $\type_1$ to $\type_2$. Its syntax is similar to the one used for the conversion constraints, except for a single difference: the ``ax'' indexed to the entailment symbol whereas conversion constraints use ``ct''.

For a conversion axiom $k : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_s \rightsquigarrow \type_t=\term $, to be applicable to implicitly convert $\type_1$ to $\type_2$, it must be possible to unify the axioms' final conversion monotype $\type_s \rightsquigarrow \type_t$ with $\type_1 \rightsquigarrow \type_2$. Further, after applying the type substitution resulting from the unification to its conditions, these should consist only of ground types and must all be satisfied under $\imEnv$.

In order to prove the satisfiability of the conditions, we use another judgment \textsc{Theorem}. Its specification resembles \textsc{Axiom}'s but it allows for the conversions to be satisfied by composing conversion axioms.

The highlighted parts are important for the construction of the conversions but can be ignored for now.

\begin{figure}
  \begin{flushleft}
  \namedRuleform{ \convax{\imEnv}{j}{\type_1}{\type_2}}
                {Axiom Conversion Judgment}
\end{flushleft}

\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}

\inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \convax{\imEnv}{j}{\type_1}{\type_2} }
  \\[5mm]
  \inferrule*[right=Axiom]
  {
    (k : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_s \rightsquigarrow \type_t=\term) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type}]\type_s
    \\
    \type_2 = [\overline{\tyVar}\mapsto \overline{\type}]\type_t
    \\
    \forall\; j_i' \in [\overline{a} \mapsto \overline{\type}]\overline{j_i}\;:\;(\convth{\imEnv}{j_i'}{\type_{s_i}}{\type_{t_i}}{\Theta_i})
    \\
    \forall i . ftyvsOf(\type_{s_i}) = ftyvsOf(\type_{t_i}) = \bullet
  }
  { \convax{\imEnv}{j}{\type_1}{\type_2}}
  \end{array}
  \]
  \\[5mm]
    \begin{flushleft}
  \namedRuleform{ \convth{\imEnv}{j}{\type_1}{\type_2}{\Theta}}
                {Theorem Conversion Judgment}
    \end{flushleft}
    \[
    \begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
  \inferrule*[right=Theorem]
  {
    (k : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_s \rightsquigarrow \type_t=\term) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type}]\type_s
    \\
    \type_3 = [\overline{\tyVar}\mapsto \overline{\type}]\type_t
    \\
    \forall\; j_i' \in [\overline{a} \mapsto \overline{\type}]\overline{j_i}\;:\;(\convth{\imEnv}{j_i'}{\type_{s_i}}{\type_{t_i}}{\Theta_i})
    \\
    \convth{\imEnv}{conv_{rest}}{(\overline{\Theta_i}\;\type_3)}{\type_2}{\Theta_{rest}}
  }
{ \convth{\imEnv}{j}{\type_1}{\type_2}{\Theta_{rest} \circ \overline{\Theta_i}}}
  \end{array}
\]  
  \caption{Implicit Conversion Judgment}
  \label{ICJ}
\end{figure}

\subsubsection{Finding the Dominator}
It follows immediately from the definition of dominator together with the \textsc{Unification} rule in \fref{ICJ} that for any environment, the dominator of a single conversion constraint $\convconst{\imEnv}{j}{\type}{a}$ is $\type$. This reasoning also applies if the ``source'' types of all the constraints are the same.

In more complex cases, we look for the dominator by first computing, for each constraint $\convconst{\imEnv_i}{j_i}{\type_{i}}{a}$, the set $R_i$ of types reachable from $\type_i$ under the implicit environment $\imEnv_i$. The intersection of all $R_i$ constitutes the set $D$ of possible dominators: for a type $\type_d$ to be in it, it must be reachable from all the types $\overline{\type_{i}}$. We now compute the set $P$ of all paths from all $\type_i$ to all types $\type_d \in D$. If there is a dominator, then it must be the (the only type) present in all paths in $P$ so we need only to compute the intersection.

In the presence of constraints of the form $\convconst{\imEnv_k}{j_k}{\type_s}{\type_t}$, with $a$ a type variable of $\type_t$, this constraint should be taken into account when instantiating $a$. We compute the types reachable from $\type_s$ and unify them with $\type_t$ to get the possible values for $a$ from this constraint ($R_k$). We would then have to analyze the paths from $\type_s$ to the types $\type_{t_d}$ ($\type_t$ in which $a$ was substituted by the elements $\type_d \in D$) together with the paths in $P$. If, in any of the fore mentioned cases, we are unable to compute the dominator, since either $D$ is empty and no conversion exists or the source program is ambiguous and there is no \textit{best} choice of the type to instantiate a type variable with.

In the implementation provided with this thesis, we do not fully support this approach: constraints in which $\type_t$ contains a type variable $a$ are not considered when instantiating $a$. We first go through the constraints looking for a type variable in the right hand side of the conversion monotype. Upon finding one, $\tyVar$, we collect the left hand sides of all the constraints with $a$ as the right hand side. We then compute the dominator of this set of constraints. Nonetheless, this has the desired behavior for all the constraints in which $\tyVar$ is (part of) the left hand side.

\section{Constructing the Conversion}
\label{constructing}
Once we have substituted all the type variables in the conversion constraints, we assess their entailability by constructing the conversions. This process is central for the elaboration of the program since it yields the appropriate terms to substitute the place holding variables with. In addition, during this process that we (again) enforce our design decision of rejecting ambiguous programs.

For each constraint $\convconst{\imEnv_i}{j_i}{\type_{s}}{\type_{t}}$ (the conversion monotype $\type_{s}\rightsquigarrow \type_{t}$ is now ground) we compute all conversion paths (according to \ref{paths}) from $\type_{s}$ to $\type_{t}$. If multiple paths are found, the program is ambiguous and as such we reject it. Otherwise we are assured there is only one way to compose the conversion axioms into a conversion path.

However, according to the specification in \fref{ICJ}, there may exist multiple ways in which the axioms' conditions are satisfied. Since these conditions determine the converting expression introduced in the program at compile time, entailing them in different ways would result in different converting expressions to be used in the elaborated program, which is clearly undesirable due to the unreasonable heavy burden placed on the user to be able to predict which is used.

To construct the conversion we discuss in \ref{constr} an algorithm that yields the appropriate converting expression and enforces that if any condition along the converting path can be entailed in more ways than one, the corresponding axiom will be unavailable. Since there was only one path, it will fail to it and the program will be rejected, as required by our ambiguity policy.

\section{Computations}
\label{computations}
We now discuss in detail the computations referenced in \ref{sc:cc} and \ref{constructing} in the order they appear in the text.

\subsection{Reachability}
To compute the types reachable from a given type $\type$ under a given implicit environment $\imEnv$, we start from a queue consisting of $\type$ and an empty accumulator. We traverse the environment and, for each conversion axiom, check whether it is applicable to the head of the queue $\type_{head}$ and (if so) to what types $\overline{\type_i}$ it can convert $\type_{head}$ into. We then add $\overline{\type_i}$ to the back of the queue. To check the applicability and the compute the $\overline{\type_i}$ we use the axiom tester (\ref{onestep}), which uses the \textsc{Axiom Conversion Judgment} of \fref{ICJ}.

Once we have tried all the axioms, we take the head of the queue, put it in the accumulator and iterate the process with the current queue and the entire environment $\imEnv$. We continue until there are no more elements in the queue and by then the reachable types are in the accumulator.

\subsection{Computing the Paths}
\label{paths}
To compute all the paths from a source type $\type_s$ to a target type $\type_t$, we keep an accumulator and a list $L$ of paths under construction. We start with an empty accumulator and a single path consisting of a single type $\type_s$. We pick the last type $\type_{j_{n_j}}$ on the first path ($p_j = \type_{j_1}\to ... \to \type_{j_{n_j}}$) of the queue and and check if it is equal to $\type_t$. If so, we add $p_j$ to the accumulator.

Otherwise, we apply the axiom tester (\ref{onestep}) to $\type_{j_{n_j}}$ for each conversion axiom in the implicit environment. For each returned type $\type_i$ not present in $p_j$, we add a path $p_{j_i} = \type_{j_1}\to ... \to \type_{j_{n_j}} \to \type_i$ to the back of $L$. After trying every conversion axiom in the implicit environment, we delete $p_j$ from $L$ and continue with the new list of paths under construction. When $L$ becomes empty we return the accumulator.

\subsection{Axiom Tester}
\label{onestep}
To be able to assess if a conversion axiom is applicable to some given ground type $\type$ and compute the types it can implicitly convert $\type$ into, we must design an algorithm capable of handling multiple cases.

 If the conversion axiom $i : \forall \overline {\tyVar} . \overline{(j_i : \convmono_i)} \Rightarrow \type_s \rightsquigarrow \type_t$ does not contain type variables, it suffices to check if $\type_s$ equals $\type$ and if the conditions are entailed. If so, $i$ can convert $\type$ (only) into $\type_t$. More generally, if it is possible to unify $\type_s$ with $\type$ resulting in a type substitution $\Theta$ and applying $\Theta$ to $i$ causes all type to be ground, we proceed in a similar manner.

 However, there are more complex cases. Take this conversion axiom presented in chapter \ref{cha:5}: $i_{lists}: j: a \rightsquigarrow b \Rightarrow [a] \rightsquigarrow [b] = \lambda \tmVar . map\;j\;\tmVar$. We clearly can not ignore this conversion axiom, nor can we blindly try different instantiations of $b$. We currently enforce that each type variable present on the conversion polytype, after applying $\Theta$ to it, is present both on the final conversion monotype and on the right hand side of some condition and is not present in the left hand side of any condition. Further, in order to prevent from ever ``increasing'' types (size wise), the left hand side of the final conversion monotype must not occur in the corresponding right hand side.

 In such conversions $i : \forall \overline {\tyVar} . \overline{(j_i : \convmono_i)} \Rightarrow \type_s \rightsquigarrow \type_t$, if it is possible to unify $\type_s$ with $\type$ resulting in a type substitution $\Theta$, we start by trying to entail the conditions (after having $\Theta$ applied to them). If this yields types $\overline{\type_{i_j}}$ as being possible choices for the remaining type variables $\overline{a_i}$, then we can implicitly convert $\type$ into  $([\overline{\tyVar_i} \mapsto \overline{\type_{i_j}}]\circ \Theta)\type_t$, for each appropriate tuple of $\overline{\type_{i_j}}$.



\subsection{Constructing the Conversion Expression}
\label{constr}
To compute the conversion expressions necessary to elaborate the source program into a System F program, we must use the user-provided converting expressions in the conversion axioms. These are highlighted in \fref{ICJ}.

In order to construct the conversion that satisfies some constraint $\convconst{\imEnv_1}{j_1}{\type_s}{\type_t}$, we compute a converting path from $\type_s$ to $\type_s$ almost as described in \ref{paths}.

However, we now use another variant of the axiom tester (discussed below): it ensures the conditions can only be entailed in one way and it returns the conversion expression to be used.

For each conversion constraint $\convconst{\imEnv_i}{j_i}{\type_{s}}{\type_{t}}$, we keep a converting expression under construction: a lambda abstraction ($\lambda x . body$). It is initiated to the identity function ($\lambda x. x$) and, for every necessary conversion axiom $\convax{\imEnv}{j}{\type_1}{\type_2}{\term}$ in the converting path, the lambda abstraction is updated to $\lambda x . (\term \;\;body)$. When we Finnish constructing the conversion we have also finished constructing the converting expression $exp$ that will replace the term variable present in the conversion constraint. The term $exp$ will be of the form $\lambda x . (\term_n ... (\term_1\;\;x)...)$ and have type $\type_s \to \type_t$, as required.

\subsubsection{Unambiguous Axiom Tester}

The Axiom Tester discussed in \ref{onestep} allows for the conditions in a conversion axiom to be entailed in multiple ways. That is the desired behavior for the algorithms that use it:  not using it to compute the paths could cause us to elaborate a source program that should be rejected due to its ambiguity.

This is not what we want for constructing the conversions: using an axiom $i :\forall \overline{a} . \overline{j_i : \convmono} \Rightarrow \convmono = \term$ whose conditions can be entailed in multiple ways would too cause us to elaborate an ambiguous program, since the $j_i$ could be substituted in $\term$ by multiple terms. This change is easy to implement: for each condition, we apply the algorithm to compute the possible paths \ref{paths} (with the unambiguous axiom tester instead of the axiom tester) and accept if there is only one. For cases in which there are type variables on the left hand side of the conditions, we use the version described in \ref{opt}.

Furthermore, we want the unambiguous axiom tester to return the appropriate expressions to use during elaboration. As such, we must substitute the place holding variables by conversion expression specified in the (unique) conversion axiom in the environment that satisfies it.

\subsection{Optimizations}
\label{opt}

It is clear that some parts of the process described can be optimized in an implementation: instead of computing the reachable types and the the possible paths, we can compute the reachability graphs and get the necessary information for both these steps.

Notice how we can easily modify the computation of the paths in \ref{paths} to compute all the conversion paths (the reachability graph) from a given type: it suffices to eliminate the equality check of the final type in a path against the (now non-existing) target type and take every partial path $p_j = \type_{j_1}\to ... \to \type_{j_i}$ from each path $p_j = \type_{j_1}\to ... \to \type_{j_i} \to ... \to \type_{j_{final}}$ in the accumulator.

Further, the ambiguity check discussed in the second paragraph of \ref{constructing} could be moved (for all the constraints involved in a ``finding the dominator step'') to this computation: instead of only keeping the types on the paths, we could modify them to store the axioms used at each step of the way. After taking the partial paths, we could easily verify whether that two paths exist to the same type $\type_{amb}$. In that case, not only would the conversion to $\type_{amb}$ be ambiguous as would for any type for which there is a path containing $\type_{amb}$.

As discussed in \ref{constr}, the constructing the conversion step deals with ambiguity due to conditions being in multiple ways. Finally, if we store the axioms used as just described, the constructing the conversion step could be made more efficient.



\section{Example}
We will now go through the solving of the constraints generated by the program in \fref{complex5}. Since this program is an composed by applications, we disregard the equality constraint that arises from the type annotation to better showcase the working of the graph-based constraint solver until further notice.
\subsection{Substituting Type Variables}
We recall that the generated equality constraints $E$ were: \{$a \to a \to (TyW \; a) \sim b_1 \to b_2$ ,$TyB \to TyC \sim b_3 \to b_4$, $b_2 \sim b_5 \to b_6$\}; as for the conversion constraints $Y$ we got: \{$\convconst{\imEnv_1}{j_1}{TyB}{b_1}$, $\convconst{\imEnv_2}{j_2}{TyA}{b_3}$, $\convconst{\imEnv_1}{j_3}{b_4}{b_5}$ \}.

Unifying them results in the following substitution $\Theta= [b_1 \mapsto a, \;b_2 \mapsto a \to TyW\;a, \;b_3 \mapsto TyB, \;b_4 \mapsto TyC, \;b_5 \mapsto a, \;b_1 \mapsto TyW \;a]$. The application of $\Theta$ to $Y$ yields the updated constraints $Y' = \{\convconst{\imEnv_1}{j_1}{TyB}{a}$, $\convconst{\imEnv_2}{j_2}{TyA}{TyB}$, $\convconst{\imEnv_1}{j_3}{TyC}{a} \}$.

This example results in a almost trivial graph, with three nodes and only two edges: from $TyB$ to $a$ and from $TyC$ to $a$, both indexed by the environment $\imEnv_1 = \imEnv_1 = \{i_1 : TyC \rightsquigarrow TyD, \;i_2 : TyB \rightsquigarrow TyD,\; i_3 : TyD \rightsquigarrow TyA,\;i_4 :\forall a, b . j : a \rightsquigarrow b \Rightarrow TyW\;a\rightsquigarrow TyW\;b\}$.

Following \ref{dominator}, we compute the types reachable from $TyB$ and from $TyC$:resulting in, respectively, $\{ TyB, TyD, TyA\}$ and $\{TyC, TyD,TyA \}$. The intersection of these sets is  $\{ TyD, TyA\}$ and, as such we must compute all the paths from either $TyB$ and $TyC$ to either  $TyD$ and $TyA$. It is clear to see that $TyD$ is the type present in all of the paths, and as such $TyD$ is the dominator of the constraints $\{\convconst{\imEnv_1}{j_1}{TyB}{a}, \convconst{\imEnv_1}{j_3}{TyC}{a} \}$.
\subsection{Constructing the Conversion}
