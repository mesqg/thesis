\chapter{Constraint Solving}
\label{cha:6}
We continue with the layout of the last chapter and approach typing and elaboration separetely. We will first discuss how to assess the entailability of the generated constraints. In other words, we will present our type inference algorithm. We will also go through the solving of the constraints generated by the more involved example in the last chapter.

During this phase of type-checking a program under our language, the type variables in the constraints will be substituted away by concrete types. It becomes then much easier to elaborate the program into System F: we know the conversion monotypes of each place-holding variable, so the only thing left to do is to replace them with the unambiguous System F term constructed from the implicit environment. This is presented in \ref{6.4}.

\section{Unification}
\label{sec uni}

Once we have collected the constraints, we move on to solving them. First we perform unification on the equality constraints, yielding a type substitution. We then apply this substitution on the conversion constraints.

\section{Conversion Constraints}

Take for example the program presented in \ref{cha: 6}. Ignore the user provided type of the program (and the equality constraint that involves it): we actually do not need it in such simple cases.

After solving the equality constraints and applying the type substitution to conversion constraints, these become: \{$\convconst{\imEnv_1}{j_1}{TyB}{a}$, $\convconst{\imEnv_2}{j_2}{TyB}{TyA}$, $\convconst{\imEnv_1}{j_3}{TyC}{a}$ \}.

If we were to take the conversions sequentially we would either substitute $a$ by $TyB$ or by $TyC$, depending on which we consider first. However, from we can see that we are not able to convert $TyB$ to $TyC$ nor the other way around under the environemts specified by the conversion constraints: they happen to be the same in this case $\imEnv_1 = \{i_1 : TyC \rightsquigarrow TyD, \;i_2 : TyB \rightsquigarrow TyD \}$. We would then be tempted to reject this program.

Nontheless, it is clear that in this case we have all the ingredients to fix the program by using implicit conversions (we should substitute $a$ with $TyD$). As such we have developed a graph-based constraint solver that consideres the set of conversion constraints as a whole.

\subsection{Building the Graph}

After applying the substitutions resulting from unification on the equality constraints to the conversion contraints, we build a graph of the conversion constraints, with nodes for each monotype present in the constraints and directed edges representing the need to convert from one type to the other (\textit{i.e.} each edge represents the existence of a constraint such that its conversion monotype $\convmono$ is that ordered pair). Note that these edges are indexed by the implicit environments specified by each constraint, and it may even be the case that multiple edges with the same direction exist between the same types.

To construct the graph we can just pick the first conversion constraint, create two nodes with the types present in the conversion monotype and join them by a directed edge indexed by the implicit environment. We proceed and in when a type present in the conversion monotype is already in the graph, we just build the edges from there.

We present in \fref{graph1} the graph for the program of \fref{complex5}.

The next step is to substitute the type variables by concrete types. We start from the sources and proceed until we reach the sinks. In general, there are no type variables in the sources (we require the user to provide the type of the program to be able to start from this premisse).

Starting from the sources, we follow the edges of the graph. Upon encountering a type variable $a$ (necessarily as the second part of the conversion monotype), we collect all the constraints that have $a$ as the second part of their conversion monotypes. We then call a ``find dominator'' procedure on this set of conversion constraints. The prodecure, explained bellow substitutes $a$ by the apropriate concrete type. In the case or our example, it would substitute $a$ with $TyD$. If the program is ill-typed according to our language, this procedure may fail: in fact, it is bound to fail during the solving of the constraints.

Otherwise we replace the type variable with the correct type and carry on following the edges. Once we have traversed the graph, all constraints have been entailed and the program is considered to be well typed.

\textbf{To be deleted or moved:}(In the implementation provided with this thesis, we first go through the constraints searching for a type variable in the right hand side of the conversion monotype. Upon finding one ($\tyVar$), we collect the left hand sides of all the constraints with that same right hand side. If all left hand sides are the same ($\type$), we substitute in all the conversion constraints $\tyVar$ by $\type$. Keep in mind this affects all the constraints in which $\tyVar$ is on the left hand side.)

\subsection{Finding the Dominator}
The \textit{ dominator} $d$ of a set of conversion constraints $S=\overline{\convconst{\imEnv_i}{j_i}{\type_i}{a}}$ is the concrete type such that: for all conversions $j_i$ in $S$, there is an implicit conversion in $\imEnv_i$ from $\type_i$ to $d$; and, for any other type $d'$ to which all $\type_i$'s can convert into, any conversion from $\type_i$ into $d'$ can be decomposed into a conversion from $\type_i$ to $d$ and another from $d$ to $d'$.

It follows immediately from the definition and from the ``Unification'' rule in \fref{ICR} that for any environment, the dominator of a single conversion constraint $\convconst{\imEnv}{j}{\type}{a}$ is $\type$. This reasoning also applies if the ``source'' types of all the constraints are the same.

Substituting type variables by the corresponding dominator is a consequence of a design decision of rejecting ambiguous programs: if there is no clear winner (a simpler conversion) we refuse to arbitrarily choose one the the available types. We can also think about this from an elaboration point of view: if there are multiple converting expressions that could be used (to convert into different types), none is chosen.

In more complex cases, we look for the dominator by first computing, for each constraint $\convconst{\imEnv_i}{j_i}{\type_{i}}{a}$, a reachability graph from $\type_i$ under the implicit environment $\imEnv_i$, and then analysing the resulting set of converting paths.

To compute the reachability graphs, we now introduce a judgement that states the existence of an implicit conversion between two types.
\subsubsection{Single Step Conversion Judgement}
\label{susec}
The single step conversion judgement ($\convax{\imEnv}{j}{\type_1}{\type_2}$), formalized in \fref{ICJ} states that there is a conversion axiom in $\imEnv$ that can be used to implicitly convert from $\type_1$ to $\type_2$. Its sytax is similar to the one used for the conversion constraints, except for a single difference: the ``ax'' indexed to the entailment symbol whereas conversion constraints use ``ct''.

The intuition behind this ... transitive so first move to some point then continue
\begin{figure}
  \begin{flushleft}
  \namedRuleform{ \convax{\imEnv}{j}{\type_1}{\type_2}}
                {}
\end{flushleft}

\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}

\inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \convax{\imEnv}{j}{\type_1}{\type_2} }
  \\[5mm]
  \inferrule*[right=Axiom]
  {
    (k : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_1' \rightsquigarrow \type_3'=\term) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type_a}]\type_1'
    \\
    \type_3 = [\overline{\tyVar}\mapsto \overline{\type_a}]\type_3'
    \\
    \forall\; j_i' \in [\overline{a} \mapsto \overline{\type_a}]\overline{j_i}\;:\;(\convth{\imEnv}{j_i'}{\type_{i1}}{\type_{i2}}{\Theta_i})
  }
  { \convax{\imEnv}{j}{\type_1}{\type_2}}
    \\[5mm]
  \inferrule*[right=Theorem]
  {
    (k : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_1' \rightsquigarrow \type_3'=\term) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type_a}]\type_1'
    \\
    \type_3 = [\overline{\tyVar}\mapsto \overline{\type_a}]\type_3'
    \\
    \forall\; j_i' \in [\overline{a} \mapsto \overline{\type_a}]\overline{j_i}\;:\;(\convth{\imEnv}{j_i'}{\type_{i1}}{\type_{i2}}{\Theta_i})
    \\
    \convth{\imEnv}{conv_{rest}}{(\overline{\Theta_i}\;\type_3)}{\type_2}{\Theta_{rest}}
  }
{ \convth{\imEnv}{j}{\type_1}{\type_2}{\Theta_{rest} \circ \overline{\Theta_i}}}
  \end{array}
\]  
  \caption{Implicit Conversion Judgement}
  \label{ICJ}
\end{figure}

\subsubsection{Reachability}
To compute the reachability graph from a type $\type$ in a given implicit environment $\imEnv$, we start from a queue consisting of $\type$ and an empty accumulator. We then traverse the environment and check, for each conversion axiom $i : \forall \overline {\tyVar} . \overline{(j : \convmono)} \Rightarrow \convmono$, whether it is applicable (by using the conversion resolution judgement). If so, we add the ``returned'' type to the back of the queue and continue with the other conversion axioms. Once we have tried all the axioms, we pop the first element of the queue and put it in the accumulator and iterate the process with the current queue and the entire environment $\imEnv$. We continue until there are no more elements in the queue and by then the reachable types are in the accumulator.

\section{Constructing the conversion}
\label{6.4}
\section{Example}
