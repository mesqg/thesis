\chapter{TrIC}
\label{cha:5}
This chapter presents TrIC (TRansitive Implicit Conversions), a calculus which showcases the features mentioned in Chapter \ref{cha:4}, namely type inference and implicit conversions with support for transitivity, local scoping, constrained and polymorphic conversions.

The chapter starts by presenting TrIC's syntax (Section \ref{5.1}) and typing rules (Section \ref{5.2}). Then, type inference and constraint generation are discussed (Section \ref{constraint generation}) and exemplified (Section \ref{eg5}). Finally, the translation of a TrIC program is addressed by Section \ref{5.5}.
\section{Syntax}
\label{5.1}
TrIC extends HM with implicit type conversions. As such, the focus of this section is on the syntax of this novel feature of the language, namely on the terms that introduce implicit conversions into the language, $locimp$ (short for local implicit), and on the implicit environment they determine ($\imEnv$). As will be explained in Chapter \ref{cha:6}, the implicit environment is crucial for solving the conversion constraints generated by a program.

A $locimp$ term ($locimp \; \term_1:\typeS_{\rightsquigarrow}\; in\; \term_2$) is composed of a conversion axiom ($\term_1: \typeS_{\rightsquigarrow}$) and any (sub)term $\term_2$. Similarly to how a $let$ expression extends the typing environment $\tyEnv$ for its right hand side term, a $locimp$ expression extends the implicit environment ($\imEnv$) under which its expression $\term_2$ is typed. 

Conversion axioms introduce a term and specify its conversion type. A conversion type is either a conversion monotype or a conversion polytype. Conversion monotypes ($\convmono::=\type_s \rightsquigarrow \type_t$) are simply a pair of monotypes (as defined in HM); $\type_s$ represent the source type and the $\type_t$ the target type of the conversion. A conversion polytype ($\convpoly::=\forall \overline {\tyVar} . \overline{(j : \type_{\rightsquigarrow})} \Rightarrow \type_{\rightsquigarrow}$) specifies a set of type variables $\overline {\tyVar}$, a set of conditionals $\overline{(j : \type_{\rightsquigarrow})}$ (identifiers bound to conversion monotypes) and a final conversion monotype $\type_{\rightsquigarrow}$. 
An implicit environment $\imEnv$ is simply a set of available conversions axioms. Intuitively, having an implicit conversion $\term: \type_1 \rightsquigarrow \type_2$ in $\imEnv$ states that, under $\imEnv$, $\type_1$ is implicitly convertible to $\type_2$ and that $\term$ should be used to convert terms from $\type_1$ to $\type_2$.

Programs consist of data declarations (responsible for the introduction of data and type constructors to the typing environment), a single expression and a type annotation (the type of the whole program). In this text, the type annotation is required as we perform local type inference (see Chapter \ref{cha:6}). However, it is not a necessity of a language with implicits but rather a design choice to be discussed in Chapter \ref{cha:6}. The full syntax for TrIC is given in \fref{mlsyntax}, where the syntax concerned with implicit conversions is highlighted.

\subsection{Polymorphic Conversions}
\label{polymorphic conversions}
As previously stated and deducible from the syntax, TrIC allows the programmer to write conversion axioms ($\term : \forall \overline{a}.\overline{j_i : \convmono_i} \Rightarrow \convmono$) parameterized over type variables $\overline{a}$  and constrained by the conditions ($\overline{j_i : \convmono_i}$) imposed. These are satisfied if, for each required conversion monotype $\convmono_i$, an implicit conversion of type $\convmono_i$ can be constructed from the conversion axioms in scope (\textit{i.e.} in the implicit environment).

TrIC allows the identifiers $j_i$'s to be used in the converting expression $\term$. This way the user is able to write a conversion axiom that itself behaves differently in different places in the code (it behaves according to the implicits that satisfy its conditions), with the added benefit of using a single identifier to stand for a conversion expression. Each identifier will be substituted, during compile time, by the appropriate converting expression constructed from the implicit environment (as will be seen in detail in Chapter \ref{cha:6}).

The example mentioned in Section \ref{param4}, in which the goal was to define an implicit conversion from a list of any type $a$ to a list of any other type $b$ provided an implicit conversion from $a$ to $b$ is available, can easily be written (if a list datatype is present and a mapping function has previously been defined) as follows: $\lambda \tmVar . map\;j\;\tmVar : (j: a \rightsquigarrow b) \Rightarrow [a] \rightsquigarrow [b]$.
\subsection{Constraints in the Conversion Axioms}
\label{constraints}
In order for type inference to terminate, some requirements are enforced on the size of the types present in the conversion axioms. Further, type variables in the axioms must abide by some rules in order to avoid ambiguity and facilitate the solving process (see Chapter \ref{cha:6}). The complete set of requirements for the conversion axioms $\term : \forall \overline{a}.\overline{(j_i:\type_{s_i} \rightsquigarrow \type_{t_i})}\Rightarrow \type_s \rightsquigarrow \type_t$ is:
\begin{itemize}
\item in the final monotype of an axiom, the target type $\type_t$ must not be larger than the source type $\type_s$, \textit{i.e.}, conversions to larger types are not allowed;
\item the size of the conversion monotype in each condition $\type_{s_i} \rightsquigarrow \type_{t_i}$ (the sum of the sizes of its source and target types) must be strictly inferior to the size of the final conversion monotype $\type_{s} \rightsquigarrow \type_{t}$;
\item all type must be well-scoped;
\item any type variable present in the source $\type_{s_i}$ of some condition must appear in the source type of the final conversion monotype $\type_s$;
\item the set of all the type variables in the conditions is a subset of the set of the type variables in the final conversion monotype;
  \item each variable in the target of the final monotype $\type_t$ must be present either on the source type $\type_s$ of the final conversion monotype or in the target type of some condition $\type_{t_i}$.
\end{itemize}

\begin{figure}
   \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  pgm ::= \overline{data};\term\highlight{:\typeS}\hfill Program\\
  data\,::= data\;T\;\tyVar=\overline{K_i\;\overline{\type_{i_j}}}\hfill Data\;Declaration
  \\[5mm]
  \type ::= \tyVar\,|\,\type_1\to\type_2\,|\,T\,\overline{\type}\hfill Monotypes\\
  \typeS ::= \type\,|\,\forall\tyVar.\typeS\hfill Polytypes
  \\[5mm]
    \highlight{\type_{\rightsquigarrow} ::= \type \rightsquigarrow \type}\hfill \highlight{Conversion\;Monotypes}\\
  \highlight{\typeS_{\rightsquigarrow} ::= \forall \overline {\tyVar} . \overline{(j : \type_{\rightsquigarrow})} \Rightarrow \type_{\rightsquigarrow}}\hfill \highlight{Conversion\;Polytypes}
  \\[5mm]
  \term ::= \tmVar\;|\,\lambda \tmVar.\term\;|\,\term_1 \; \term_2\;|\, K \;|\, case \, \term_1 \, of\, \overline{(K_i \overline{\tmVar_{i_j}}) \rightarrow \term_2} \hfill Terms\\
  \phantom{\term ::}|\, let \, \tmVar :\typeS\, =\, \term_1 \,in\, \term_2  \;|\,\highlight{ locimp \; \term : \typeS_{\rightsquigarrow}\; in\; \term_2}
  \\[5mm]
  \highlight{\imEnv::=\overline{\term : \typeS_{\rightsquigarrow}}} \hfill \highlight{Implicit\;Environment}
  \\[5mm]
  \tyEnv::=\bullet\,|\,\tyEnv,\tmVar:\typeS\,|\,\tyEnv,\tyVar\,|\,\tyEnv,K:\typeS\,|\,\tyEnv,T \hfill \phantom{xxxxxxxxxxxxxxx} Typing\; Environment

  \end{array}
\]
  \caption{TrIC's syntax}
  \label{mlsyntax}
\end{figure}

\section{Typing}
\label{5.2}
The top-level program typing rules are standard for languages with data types. The type annotation will be taken into account when performing type inference on the programs's term. Program typing rules and data declaration typing are shown respectively in \fref{pgmtyping} and \fref{datadtyping}.

As for term typing, shown in \fref{termtyping} (where the ``$\tyEnv \vdash_{ty} \typeS$'' judgment is the same as in \fref{tywf}), the main differences from standard HM are the typing rules for application and case expressions. The intuition for rule \textsc{TmApp} is that it is no longer required that the type of the operand ($\type_s$) matches the left side of the (function) type of the operator ($\type_{arg} \to \type_{res}$) literally, but rather that it is possible to implicitly convert from $\type_s$ to $\type_{arg}$ under the current implicit environment (henceforth denoted by $\convmust{I}{\type_s}{\type_{arg}}$, according to \fref{ICJ2}).

Similarly, \textsc{TmCase} requires the weaker condition that the type of the scrutinee is convertible to the (unique) type of the pattern(s). Further, instead of imposing the same type to all of the alternatives, it merely imposes that every alternative is convertible to a common type.

When typing a \textit{locimp}, (\textsc{TmLocImp} rule) the converting expression $\term_{1}$ introduced by the conversion axiom ($ \term_{1} : \overline{j_i : \type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_{s} \rightsquigarrow \type_{t}$) of $locimp$ must have type $\type_{s} \to \type_{t}$, under an extended typing environment where the $j_i$'s have type $\type_{s_i} \to \type_{t_i}$, since the $j_i$'s will later be substituted int$\term_1$ by terms of those types. The subterm $\term_2$ of $locimp$ is then typed under an implicit environment extended with the conversion axiom $ \term_{1} : \overline{j_i : \type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_{s} \rightsquigarrow \type_{t}$. As explained in Chapter \ref{cha:4}, this means that we can use the newly defined axiom in order to ``fix'' $\term_2$.

Note that the local scope means that if $\term_2$ has some sub-terms whose types do not match but can be made to match by application of $ \term_{1} : \overline{j_i : \type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_{s} \rightsquigarrow \type_{t}$, then the axiom will be used. If, however, the entire $locimp$ term is a sub-term of some term $\term_{super}$ and its type does not conform to expected, the conversion it introduces will not be considered in order to fix the program. If that is the intended behavior, the conversion axiom needs to be available in a broader scope: it should be defined in a $locimp$ that has $\term_{super}$ as a subterm.

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \progTyping{\imEnv}{\tyEnv}{pgm}{\typeS}}
                {Program Typing}
\end{flushleft}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
%\inferrule*[right=Ann]
%           {\progTyping{\imEnv}{\tyEnv}{\overline{data};pgm}{\typeS}}
 %          {\progTyping{\imEnv}{\tyEnv}{\overline{data};(pgm:\typeS)}{\typeS}}
  %         \\[5mm]           
\inferrule*[right=Data]
           {\dataDTyping{\tyEnv}{\overline{data}}{\tyEnv'}\ \\\progTyping{\imEnv}{\tyEnv'}{pgm}{\typeS}}
           {\progTyping{\imEnv}{\tyEnv}{\overline{data};pgm}{\typeS}}
           \\[5mm]           
\inferrule*[right=Expression]
           {\txTerm{\imEnv}{\tyEnv}{\term}{\typeS}}
           {\progTyping{\imEnv}{\tyEnv}{\term}{\typeS}}           
\end{array}
\]
\caption{Program Typing}
\label{pgmtyping}
\end{figure}

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \dataDTyping{\tyEnv}{data}{\tyEnv'} }
                {Data Declaration Typing}
\end{flushleft}
\[
\inferrule*[right=Decl]
           { }
           {\dataDTyping{\tyEnv}{(data\;T\;\tyVar=K\;\overline{\type})}{\tyEnv,T,(K:\tyAbs{\tyVar}{\overline{\type} \rightarrow T\;\tyVar})}}
\]
\caption{Declaration Typing}
\label{datadtyping}
\end{figure}

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \sTermTyping{\imEnv}{\tyEnv}{\term}{\typeS} }
                {Term Typing}
\end{flushleft}
%\begin{comment}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
    \inferrule*[right=Var]
             {(\tmVar : \typeS)\in\tyEnv}
             {\sTermTyping{\imEnv}{\tyEnv}{\tmVar}{\typeS}}

             \quad\quad
             
  \inferrule*[right=Constr]
             {(K:\typeS) \in \tyEnv}
             {\sTermTyping{\imEnv}{\tyEnv}{K}{\typeS}}
            \\[5mm]

  \inferrule*[right=TmApp]
  {
  \sTermTyping{\imEnv}{\tyEnv}{\term_1}{\type_{arg} \to \type_{res}} \\
  \sTermTyping{\imEnv}{\tyEnv}{\term_2}{\type_s}\\
  \convmust{\imEnv}{\type_s}{\type_{arg}}
  }
  { \sTermTyping{\imEnv}{\tyEnv}{\term_1\, \term_2}{\type_{res}} }

  \\[5mm]

  \inferrule*[right=TmAbs]
  {
  \sTermTyping{\imEnv}{\tyEnv, \tmVar : \type_1}{\term}{\type_2}
  }
  { \sTermTyping{\imEnv}{\tyEnv}{\lambda \tmVar . \term}{\type_1 \to \type_2} }
  \\[5mm]

  \inferrule*[right=TmLet]
  {
  \txTerm{\imEnv}{\tyEnv,x:\typeS_1}{\term_1}{\typeS_1} \\
  \txTerm{\imEnv}{\tyEnv,\tmVar:\typeS_1}{\term_2}{\type_2}
  }
  { \txTerm{\imEnv}{\tyEnv}{let\,\tmVar:\typeS_1=\term_1\,in\,\term_2}{\type_2} }

  \\[5mm]
  \inferrule*[right=TmCase]              
             {\overline{(K_i : \forall a . \overline{\type_{i_k}} \rightarrow T \;a)\in \tyEnv}
               \\
               \txTerm{\imEnv}{\tyEnv}{e_1}{\type_1}
               \\
               \overline{\txTerm{\imEnv}{\tyEnv,\overline{\tmVar_{i_j}}:[a \mapsto \type]\overline{\type_{i_k}}}{e_i}{\type_i}}
               \\
               \convmust{\imEnv}{\type_1}{T\;\type}\\
               \overline{\convmust{\imEnv}{\type_i}{\type_2}}\\
               %fresh\;b
             }
             {\txTerm{\imEnv}{\tyEnv}{case\;e_1\;of\;\overline{(K_i\;\overline{x_{i_j}})\rightarrow e_i}}{\type_2}}
             
  \\[5mm]
  \inferrule*[right=TmLocimp]
  {
  \sTermTyping{\imEnv}{\tyEnv,\overline{\tyVar},\overline{j_i :\type_{s_i} \to \type_{t_i}}}{\term_1}{\type_s \to \type_t} \\
  \sTermTyping{\imEnv,\term_1:\forall \overline{\tyVar}.\overline{j_i :\type_{s_i} \rightsquigarrow \type_{t_i}}\Rightarrow\type_s \rightsquigarrow \type_t}{\tyEnv}{\term_2}{\type_2}
  }
  { \sTermTyping{\imEnv}{\tyEnv}{(\iLocal{\forall \overline{\tyVar}.\overline{j_i :\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow\type_s \to \type_t}{\term_1}{\term_2})}{\type_2} }
 
  \\[5mm]
  \inferrule*[right=Forall-Intro]
             {\sTermTyping{\imEnv}{\tyEnv,\tyVar}{\term}{\typeS}}
             {\sTermTyping{\imEnv}{\tyEnv}{\term}{\forall \tyVar.\typeS} }

  \\[5mm]
  \inferrule*[right=Forall-Elim]
             {\sTermTyping{\imEnv}{\tyEnv}{\term}{\forall \tyVar. \typeS}\\
               \tyEnv \vdash_{ty} \type }
             {\sTermTyping{\imEnv}{\tyEnv}{\term}{[\tyVar \mapsto \type]\typeS} }           
  
\end{array}
\]
\caption{TrIC's Term Typing}
\label{termtyping}
\end{figure}

\section{Constraint Generation and Type Inference}
\label{constraint generation}
To infer the type of a program, a standard two-phased approach is used. First, the typing environment is built from the data declarations and the final term is traversed to collect both the equality constraints (identical to HM) and the novel conversion constraints. The second phase consists of solving all the constraints.

Since the implicit environment is extended (according to the scope of the $locimp$ terms) during the traversal, constraints must include the implicit environment under which they were generated in order to know which conversions axioms were available at this point in the program. A conversion constraint with respect to the conversion monotype $\type_{source} \rightsquigarrow \type_{target}$ and generated under the implicit environment $\imEnv$ is henceforth denoted by $\convX{\imEnv}{\type_{source}}{\type_{target}}$. It states that, under $\imEnv$  it must be possible to implicitly convert from $\type_{source}$ to $\type_{target}$. The process of entailing conversion constraints is explained in detail in Chapter \ref{cha:6}.

As show in the top-level inference rule (\fref{toplevel}), TrIC assigns type schemes to its programs. The first premise is closely related to this chapter, as it is concerned with the collection of equality and conversion constraints, denoted by $E$ and $Y$ respectively. The second and third premises determine type substitutions ($\Theta_E$ and $\Theta_Y$) that shall be discussed in Chapter \ref{cha:6} as they regard solving the constraints (in particular, $\Theta_Y$ is one of the main contributions of this thesis and is discussed in Section \ref{sc:cc}). The fourth determines a term substitution $\varphi$ to be discussed in Section \ref{constructing}.

\fref{typeinf} shows the rules for type inference and constraint generation (the highlighted part regards term elaboration and can be ignored for now). The generated constraints are easy to understand if we keep in mind HM's generation of constraints as well as the intuition provided when explaining the typing rules. Upon encountering an application ($\term_1\;\term_2$), constraints are generated as follows: if the operator $\term_1$ has type $\type_1$ and the operand $\term_2$ type $\type_2$, $\term_1\;\term_2$ is typed as having type $\tyVar$ and construct an equality constraint specifying that $\type_1$ is of the form $b \to \tyVar$, for fresh type variables $a$ and $b$. A conversion constraint specifying the need to be able to implicitly convert from $\type_2$ to $b$, under the current implicit environment $\imEnv$ is also generated. In essence, these constraints state that neither the type of the application nor the type accepted by the operator are known at this time, but it must be possible to implicitly convert from the type of the operand $\type_2$ to the type expected by the operator (otherwise the application would be ill-typed).

The idea for \textsc{Case} expressions ($case\;e_1\;of\;\overline{(K_i\;\overline{x_i})\rightarrow e_i}$) is that it must be feasible to implicitly convert from the type of the scrutinee to (an instantiation of) the type specified by the data constructor on the patterns; and that all the types of the alternatives are convertible to one common type. Concretely, for a scrutinee  $\term_1$ with type $\type_1$, a conversion constraint from $\type_1$ to a fresh type variable $b$ is generated. This type variable $b$ is then constrained to be equal to the type of each pattern in the case expression. Another type variable $d$ is generated and, likewise, it is constrained to be equal to the type $\type_i$ of each resulting expression in the alternatives, computed under the typing environment extended by binding the variables in the patterns to the appropriate types. Other terms in TrIC merely collect the constraints of their sub-expressions.

After collecting the constraints generated by the term, one last equality constraint is added: the type resulting from type inference on the term must be equal to the type in the type annotation. Section \ref{eg5} discusses some of the rationale for this last equality constraint.

Note that the first premise of both \textsc{Let} and \textsc{LocImp} use the top-level judgment. This means that the respective terms $\term_1$ are typed locally and do not generate constraints as far a their ``superterms'' are concerned. The local typing enables both of these terms to be assigned type schemes, allowing for polymorphic \textsc{let} and polymorphic conversion axioms, respectively.

\begin{figure}
\begin{flushleft}
  \namedRuleform{ \elabTerm{\imEnv}{\tyEnv}{\term}{\typeS}{\term'}}
                {}
\end{flushleft}
\[
\inferrule*[]
           {\tyInfElab{\imEnv}{\tyEnv,\overline{a}}{\term}{\type'}{E}{Y}{\term'}
           \\\Theta_E = unify(E)
           \\\Theta_Y = dominator(\Theta_E \;Y)
           \\\varphi = conversions (\Theta_Y  (\Theta_E Y))
             \\fv(\Theta_Y(\Theta_E(\type')))\subseteq \overline{\tyVar}
             \\(\Theta_Y(\Theta_E(\type')))=\type}             
           {\toptype{\imEnv}{\tyEnv}{\term}{\forall \overline{\tyVar}.\type}{\varphi(\term')}}
           \]
           

\caption{TrIC's top-level inference judgment}
\label{toplevel}
\end{figure}


\begin{figure}
\begin{flushleft}
  \namedRuleform{ \tyInfElab{\imEnv}{\tyEnv}{\term}{\type}{\eqCts}{\imCts}{\term'}}
                {}
\end{flushleft}
\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
  \inferrule*[right=Var]
             {(\tmVar : \forall \overline{\tyVar}.\type)\in\tyEnv \\ fresh b}
             {\tyInfElab{\imEnv}{\tyEnv}{\tmVar}{[\tyVar\mapsto b]\type}{\bullet}{\bullet}{\tmVar'}}

             \quad\quad
             
  \inferrule*[right=Constr]
             {(K:\forall \tyVar . \type) \in \tyEnv\\ \overline{b} \; fresh}
             {\tyInfElab{\imEnv}{\tyEnv}{K}{[\tyVar \mapsto \overline{b}]\type}{\bullet}{\bullet}{K'}}
            \\[5mm]

  \inferrule*[right=Abstraction]
             {\tyInfElab{\imEnv}{\tyEnv,\tmVar:\tyVar}{\term}{\type}{\eqCts}{\imCts}{\term'}\\fresh\;a}
             {\tyInfElab{\imEnv}{\tyEnv}{\lambda \tmVar . \term}{\tyVar \rightarrow \type}{\eqCts}{\imCts}{\term'}}

\\[5mm]
  
  \inferrule*[right=Application]
  {
  \tyInfElab{\imEnv}{\tyEnv}{\term_1}{\type_1}{\eqCts_1}{\imCts_1}{\term_1'} \\
  \tyInfElab{\imEnv}{\tyEnv}{\term_2}{\type_2}{\eqCts_2}{\imCts_2}{\term_2'}
  \\ fresh\;a,\;b,\;j
  }
  { \tyInfElab{\imEnv}{\tyEnv}{\term_1 \term_2}{\tyVar}{\eqCts_1 , \eqCts_2 , (\type_1 \sim b \rightarrow a)}{\imCts_1 ,\imCts_2 , \highlight{(j,}\convX{\imEnv}{\type_2}{b}\highlight{)}}{\term_1'(j \; \term_2')} }
  
  \\[5mm]
  
  \inferrule*[right=Case]
             {\overline{(K_i : \forall a . \overline{\type_{i_k}} \rightarrow T \;a)\in \tyEnv}
               \\
               \tyInfElab{\imEnv}{\tyEnv}{e_1}{\type_1}{E_1}{Y_1}{e_1'}
               \\
               \overline{\tyInfElab{\imEnv}{\tyEnv,\overline{\tmVar_{i_j}}:[a\mapsto b]\overline{\type_{i_k}}}{e_{2i}}{\type_i}{E_i}{Y_i}{e_{2i}'}}
               \\
               fresh\;b,\,d,\,j_1,\,\overline{j_i}\\
               E=E_1,\overline{E_i}\\Y=Y_1,\highlight{(j_1,}\convX{\imEnv}{\type_1}{T\;b}\highlight{)},\overline{Y_i},\overline{\highlight{(j_i,}\convX{\imEnv}{\type_i}{d}\highlight{)}}
             }
             {\tyInfElab{\imEnv}{\tyEnv}{case\;e_1\;of\;\overline{(K_i\;\overline{x_{i_j}})\rightarrow e_{2i}}}{d}{E}{Y}{\highlight{case\;(j_1\;e_1')\;of\;\overline{(K_i'\;\overline{\tmVar_{i_j}'})\rightarrow j_i\;e_{2i}'}}}}
\\[5mm]
  
  \inferrule*[right=Let]
  {
  \elabTerm{\imEnv}{\tyEnv}{\term_1}{\typeS_1}{\term_1'} \\
  \tyInfElab{\imEnv}{\tyEnv,x:\typeS_1}{\term_2}{\type_2}{\eqCts_2}{\imCts_2}{\term_2'}
  }
  { \tyInfElab{\imEnv}{\tyEnv}{let\,\tmVar:\typeS_1=\term_1\,in\,\term_2}{\tyVar}{\eqCts_1 , \eqCts_2}{\imCts_1 ,\imCts_2}{let\,\tmVar:\typeS_1=\term_1'\,in\,\term_2'} }
  \\[5mm]
  
  \inferrule*[right=LocImp]
  {
    \elabTerm{\imEnv}{\tyEnv,\overline{j_i :\type_{s_i}\to\type_{t_i}}}{\term_1}{\forall \overline{a}.\type}{\term_1'}\\
    unify(fv(\type_{source} \to \type_{target}), \type \sim \type_{source} \to \type_{target})=\theta\\
  \tyInfElab{\imEnv,\term_1:\forall \overline{\tyVar}.\overline{j_i :\type_{s_i}\rightsquigarrow\type_{t_i}}\Rightarrow\type_{source} \rightsquigarrow \type_{target}}{\tyEnv}{\term_2}{\type}{\eqCts}{\imCts}{\term_2'}
  }
  { \tyInfElab{\imEnv}{\tyEnv}{(\iLocal{\forall \overline{\tyVar}.\overline{j_i :\type_{s_i}\rightsquigarrow\type_{t_i}}\Rightarrow\type_{source} \rightsquigarrow \type_{target}}{\term_1}{\term_2})}{\type}{\eqCts}{\imCts}{\term_2'}}
  
\end{array}
\]
\caption{Type Inference and Partial Translation}
\label{typeinf}
\end{figure}
\section{Translation to a ITC-free language}
\label{5.5}
Implicit type conversions require type information that is no longer present at runtime. In order to overcome this hurdle, a TrIC program is first translated to a language without implicit conversions and for which there is an interpreter.

In the implementation provided with this thesis, this target language is System F, which is a proper subset of the intermediate language used by GHC (System $F_C$ \cite{fc}), so that it can later be adapted to extend GHC. However, for the sake of exposure, the main text is concerned with the translation of a TrIC program into the non-highlighted subset of the language as show in \fref{mlsyntax}. This (subset) language is also a subset of the KHC, which means that, after the translation, the KHC could be used to run the program. \textbf{The translation to System F is shown in the Appendix \ref{appsysf}.}

%Our goal is to elaborate this language into System F. Afterwards we could use any existing System F compiler to optimize and translate our program into machine code for it to be run, but that is out of the scope of this thesis.

This translation involves using the converting expressions introduced with each conversion axiom to effectively transform an ill-typed program into a well-typed program of the target language.

Note that conversion constraints specify conversion monotypes (pairs of types such that the first needs to be convertible into the second); these constraints are relations between the types of subterms of applications or between subterms of case expressions. In addition, the implicit environment is a set of pairs of a conversion type (again a relation between types) and an expression capable of converting from the source type to the target type.

The idea is to introduce place-holding terms (usually denoted by $j$) in the program to act as hooks onto which the appropriate converting expressions are inserted. These converting expressions act as bridges between the subterms of applications and case expressions. Whenever a conversion constraint $\convX{\imEnv}{\type_s}{\type_t}$ is generated, it is stored together with its corresponding place-holder, as is specified in \fref{typeinf}: ($j,\convX{\imEnv}{\type_s}{\type_t}$). This approach ensures that the converting expression (computed as explained in Chapter \ref{cha:6}) is inserted in the correct place in the code: it will substitute the place-holder $j$. An advantage of using  with place-holders is that it allows the collection of all the constraints generated by the program before the solving process starts, providing a clear separation of the two phases.


Terms/programs with place-holders as known as \textit{partially elaborated}. Note that in an application $\term_1 \term_2$ a place holding variable $j$ is put between the partially elaborated operator $\term_1'$ and operand $\term_2'$. The converting expression that will substitute $j$ will be a lambda abstraction, whose type is a function type from the type of the operand to the type expected by the operator. In case the types already match, it will simply be substituted by the identity function.

Similarly, for case expressions $case\;e_1\;of\;\overline{(K_i\;\overline{x})\rightarrow e_{2i}}$, place-holders will be put to the left of the scrutinee and of the terms returned from the alternatives so that they can be later replaced by the needed conversions. Since no other terms generate conversion constraints, no other terms introduce place-holders.

%By keeping track of this pairing of place holders and constraints, it suffices to construct a conversion expression that conforms to the conversion types of the constraints  from the implicit environment and then substitute the place holding variable by the corresponding converting expressions. 

\section{Examples}
\label{eg5}
Two example programs in TrIC are now presented. Besides showcasing the syntax, these illustrate the constraint generation process.
\subsection{A Simple Example}


The first program, in Example \ref{simple5}, defines one data type (assume \textit{Float} and \textit{Int} to be previously defined base types), a simple conversion axiom and a final term in conspicuous need of that implicit conversion. All axioms that appear in the program before any (non-\textit{locimp}) term can be considered as having a \textit{global} scope which is the case for the axiom ``${\lambda \tmVar.3.1415}: \text{Int} \to \text{Float}$'' defined in this example. Such axioms may be used anywhere in the program, except in the converting expressions introduced by prior axioms.

We will now collect the constraints generated by this program, as described in Section \ref{constraint generation}. Declarations construct the typing environment, without generating any constraint. The top-level expression of the program is a $locimpl$ term: its first part introduces a new conversion axiom into the implicit environment; its second is an application.

Both subterms of the application are typed without generating constraints. The application itself generates one equality constraint (Int $\to \text{DKK} \sim b \to a$) and one conversion constraint: $\convX{\imEnv}{\text{Float}}{b}$, $\imEnv = \lambda \tmVar.3.1415 : \text{Int} \to \text{Float}$. Another equality constraint is generated from the type annotation: $a \sim \text{DKK}$.

\begin{eg}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;\text{DKK}=K_{\text{DKK}}\;Float;\\
  %data\;\text{CHF}=K_{\text{CHF}}\;Float;\\
  %data\;\text{Wallet}=K_{\text{Wallet}}\;\text{EUR}\\[3mm]
  (\monolocal{Int}{Float}{\lambda \tmVar.3.1415} (K_{\text{DKK}}\;1))\\
  %\monolocal{i}{\text{CHF}}{\text{EUR}}{\lambda \tmVar . (K_{\text{EUR}}\;32.4)}{K_{\text{Wallet}}\;(K_{\text{CHF}}\;24.0)}\\
  : \text{DKK}
\end{array}
\]
%\caption{A TrIC program}

\caption{A simple TrIC program.}
\label{simple5}
\end{eg}
\subsection{A More Involved Example}
Example \ref{complex5} presents a slightly more complex program: it defines five data types, one of which contains type variables, and five conversion axioms, one of which with a restricted scope.

By design, neither data declarations nor the declarations of axioms in the first part of $locimp$ terms generate constraints. Before generating the constraints from the top-level application $(K_{\text{Wallet}}\;(K_{\text{CHF}}\; 5.25)) \;(\monolocal{i_l}{Int}{Float}{\lambda \tmVar.3.1415} (K_{\text{DKK}}\;1))$, the constraints must be generated for its subterms. The $K_{\text{Wallet}}\;(K_{\text{CHF}}\; 5.25)$ generates two equality and two conversion constraints: one for each application. The right hand side is the same term as presented in Example \ref{simple5}, and as such generates similar constraints, but under a new implicit environment.

Note that, due to being the second part of a $locimp$ term, the constraints generated by '$K_{\text{DKK}}\;1$' specify a richer implicit environment ($\imEnv_2$, consisting of all the five conversion axioms defined in the program) than any of the other constraints, generated under $\imEnv_1$, which consists only of the ``global'' conversion axioms.

The top-level application generates an additional equality and conversion constraints, resulting in the set of equality constraints \{$Float\to \text{CHF} \sim b_1 \to b_2, a \to a \to (\text{Wallet} \; a) \sim b_3 \to b_4$, $Float \to \text{DKK} \sim b_5 \to b_6$, $b_4 \sim b_7 \to b_8$\} and in the set of conversion constraints \{$\convX{\imEnv_1}{Float}{b_1},\; \convX{\imEnv_1}{b_2}{b_3}$,\; $\convX{\imEnv_2}{Int}{b_5}$,\; $\convX{\imEnv_1}{b_6}{b_7}$~\}. A final equality constraint resulting from the user-given type is then stored: \{$\text{Wallet} \; \text{USD} \sim b_8$\}.

It should be noted that the type annotation also enables elaborating programs that would otherwise be considered ambiguous due to polymorphic functions (introduced in $let$ expressions) and polymorphic data constructors.

This program would still be well-type in TrIC without the type annotation (but its type would then be Wallet EUR). However, a minor modification to the program to include a conversion axiom from $\text{DKK}$ to $\text{USD}$ would cause this program to be rejected if no annotation was present (see Section \ref{dominator}).


\begin{eg}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;\text{EUR}=K_{\text{EUR}}\;Float;\\
  data\;\text{CHF}=K_{\text{CHF}}\;Float;\\
  data\;\text{DKK}=K_{\text{DKK}}\;Float;\\
  data\;\text{USD}=K_{\text{USD}}\;Float;\\
  data\;\text{Wallet}\;a =K_{\text{Wallet}}\;a\;a\\[3mm]
  
  \monolocal{\text{DKK}}{\text{EUR}}{\lambda \tmVar . K_{\text{EUR}}\; 28.0}\\
  \monolocal{\text{CHF}}{\text{EUR}}{\lambda \tmVar . K_{\text{EUR}}\; 1.2}\\
  \monolocal{\text{EUR}}{\text{USD}}{\lambda \tmVar . K_{\text{USD}}\; 3.4}\\
  locimp\;\lambda \tmVar. case\;\tmVar\; of\;K_{\text{Wallet}}\;x_1\;x_2 \to K_{\text{Wallet}} (j\;x_1)\;(j\;x_2)\; \\
  \phantom{xx} :(\forall a, b . j : a \rightsquigarrow b \Rightarrow \text{Wallet}\;a\rightsquigarrow \text{Wallet}\;b)\; in \\
  K_{\text{Wallet}}\;(K_{\text{CHF}}\; 5.25)\;(\monolocal{Int}{Float}{\lambda \tmVar.3.1415} (K_{\text{DKK}}\;1))
  \\
  :*: \text{Wallet} \; \text{USD}
\end{array}
\]
\caption{A more complex TrIC program}
\label{complex5}
\end{eg}


\fref{partialElab} presents the partial elaboration of the program from Example \ref{complex5}. The $j_i$'s are the place-holding variables introduced during partial elaboration.

\begin{figure}[H]
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;\text{EUR}=K_{\text{EUR}}\;Float;\\
  data\;\text{CHF}=K_{\text{EUR}}\;Float;;\\
  data\;\text{DKK}=K_{\text{DKK}}\;Float;\\
  data\;\text{USD}=K_{\text{USD}}\;Float;\\
  data\;\text{Wallet}\;\tyVar=K_{\text{Wallet}}\; \tyVar \; \tyVar;\\[3mm]
  (K_{\text{Wallet}}\;(j_2\;(K_{\text{CHF}}\;(j_1\; 5.25))))\;(j_4\; (K_{\text{DKK}}\;(j_3\;1)))) 

\end{array}
\]
\caption{Partial elaboration of the TrIC program in Example \ref{complex5}.}
\label{partialElab}
\end{figure}

%data\;TyA=A1\;|\;A2;\\
%  data\;TyB=B;\\
%  data\;TyC=C \; TyB;\\
%  data\;TyD=D;\\
%  data\;TyW\;\tyVar=W \tyVar \; \tyVar;\\[3mm]
%  \monolocal{i_1}{TyC}{TyD}{\lambda \tmVar . D}\\
%  \monolocal{i_2}{TyB}{TyD}{\lambda \tmVar . D}\\
%  \monolocal{i_3}{TyD}{TyA}{\lambda \tmVar . A2}\\
%  locimp\;i_4 :\forall a, b . j : a \rightsquigarrow b \Rightarrow TyW\;a\rightsquigarrow TyW\;b=\\
%  \phantom{xx}\lambda \tmVar. case\;\tmVar\; of\;W\;x_1\;x_2 \to W (j\;x_1)\;(j\;x_2)\;in \\
%  W\;B\;(\monolocal{i_l}{TyA}{TyB}{\lambda \tmVar.B} C\;A1)
%  \\
%  :*: TyW \; T
%|\, let \, x \, =\, e_1 \,in\, e_2  \;|\,\highlight{ locimp \; i : \sigma_{\rightsquigarrow}=e\; in\; e_2


