\chapter{Constraint Solving}
\label{cha:6}

Chapter~\ref{cha:5} discussed the collection of the constraints generated by a TrIC program as well as its partial elaboration to a subset of TrIC without implicit conversions. It remains to be assessed if the generated constraints are entailable. If so, it must be possible to complete the elaboration by substituting the place-holding variables by the appropriate converting expressions, so that the corresponding System F program type-checks. If not, or if the source program can be elaborated in multiple ways, it must be rejected.

This chapter discusses the approach taken to check the entailability of the constraints (involving a graph-based solver), the detection of ambiguous programs and the strategy to compute the converting expressions to be inserted in the code. It ends with an example showcasing constraint solving from top to bottom and the full elaboration of a program.


\section{Instantiating Type Variables}
\label{sc:cc}
The first step towards solving all the collected constraints is to perform unification (exactly as in \fref{unification}) on the equality constraints. Unless this process fails, in which case the program is immediately rejected, it yields the type substitution $\Theta$ necessary to entail the equality constraints. At this point only the conversion constraints resulting of applying $\Theta$ to the original constraints need to be entailed.
\subsection{Motivating Example}
Consider again the program presented in \ref{eg4}. Ignore for now the lack of annotation for the sake of exposing corner cases for solving the generated constraints without resorting to overly complex programs.

After solving the equality constraints and applying the resulting type substitution to conversion constraints, these become: \{$\convX{\imEnv_1}{Float}{Float}$, $\convX{\imEnv_1}{Float}{Float}$, $\convX{\imEnv_1}{\text{DKK}}{a}, \convX{\imEnv_1}{\text{CHF}}{a}$ \}.

Assuming $\imEnv_1 = \{e_1 : \text{DKK} \rightsquigarrow \text{EUR}, \;e_2 : \text{CHF} \rightsquigarrow \text{EUR}\}$, it is clear that it is not possible to convert CHF to DKK nor the other way around under; however, both are convertible to EUR. If the conversion constraints were to be solved sequentially, $a$ would be substituted by either DKK or by CHF, depending on which is considered first, thus leading to the rejection of a sensible program (according to the Chapter \ref{cha:4}'s definition of sensible).

Consequently, this section develops a graph-based constraint solver that considers multiple conversions in order to instantiate a type variable and accepts programs as long as there is always a best type to substitute a type variable with, \textit{i.e.}, as long as there is a the dominator for each set of related constraints.

\subsection{Building the Graph}
\label{graph}
After applying the substitutions resulting from unification on the equality constraints to the conversion constraints, the next goal is to substitute the remaining type variables by ground types. The constraints $\overline{\convX{\imEnv_i}{\type_{s_i}}{\type_{t_i}}}$ with remaining type variables are plotted in a graph, with nodes for each monotype and directed edges representing the need to convert from $\type_{s_i}$ to the other $\type_{t_i}$. Note that these edges are indexed by the implicit environments $\imEnv_i$ specified by each constraint, and it may be the case that multiple edges with the same direction exist between the same types.

To construct the graph, a first conversion constraint $\convX{\imEnv_1}{\type_{s_1}}{\type_{t_1}}$ is picked and, if it contains type variables, two nodes ($\type_{s_1}$ and $\type_{t_1}$) are created and joined by a directed edge indexed by the implicit environment $I_1$. Conversions are then sequentially handle and, if either of its types is a type variable already in the graph, the edges are built from there. Nodes that are not type variables are connected to the rest of the graph by exactly one edge (either incomming or outgoing), so that there is a clear order in which to entail the conversion constraints. This implies multiple nodes may be identical. \ref{}.

Upon encountering a constraint $\convX{\imEnv_i}{\type_{s_i}}{\type_{t_i}}$ such that either $\type_{s_i}$ or $\type_{t_i}$ contains but is not a type variable $a$ already in the graph, we sort the components in the graph according to a partial order to determine which to address first. Whenever $\type_s$ contains $a$, its component should be handled after the one that contains $a$. If $a$ is a variable of $\type_t$, this constraint should be taken into account when instantiating $a$, as discussed in \ref{dominator}. 

For each component, its sources are known to be ground types. Type variables in the sources of the first components to be handled could only occur due to top-level lambda abstractions. Solving the equality constraint involving the annotated type ensures their replacement by ground types. Type variables in the sources of other components are substituted by ground types before considering that component due to the partial order enforced.

The approach is to, starting from the sources, follow the edges of the graph. Upon encountering a type variable $a$ (necessarily as the second part of the conversion monotype), all the constraints that contain $a$ in the second part of their conversion monotypes are collected. Then the \textit{dominator} (\ref{dominator}) of this set of conversion constraints is computed and substitutes $a$ everywhere. The process continues by following the edges towards the sinks.

\subsection{The Dominator}
\label{dominator}
As discussed in Chapter~\ref{cha:4}, the \textit{dominator}, of a set of conversion constraints $S=\overline{\convX{\imEnv_i}{\type_{s_i}}{a}}$, with $\overline{\type_{s_i}}$ ground types, is the type $\type_{dominator}$ to which all $\type_{s_i}$'s can convert to and that, for any other type $\type_d$ such that  all $\type_{s_i}$'s can convert to $\type_d$, any conversion from any $\type_{s_i}$ to $\type_d$ can be decomposed into a conversion from $\type_{s_i}$ to $\type_{dominator}$ and another from $\type_{dominator}$ to $\type_d$.

To formalize this notion of \textit{being able to implicitly convert}, \fref{ICJ} introduces two judgments: \textsc{Theorem Conversion Judgment} specifies the existence of an implicit conversion between two types; \textsc{Axiom Conversion Judgment} is stronger as it states that only one conversion axiom is needed to implicitly convert from the source type to the target type.


\subsubsection{Conversion Judgments}
\label{susec}
The axiom conversion judgment ($\convax{\imEnv}{\type_1}{\type_2}{\term}$), formalized in \fref{ICJ} states that there is a conversion axiom in $\imEnv$ that can be used to implicitly convert from $\type_1$ to $\type_2$.

For a conversion axiom $\term : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_s \rightsquigarrow \type_t$, to be applicable to implicitly convert $\type_1$ to $\type_2$, it must be possible to unify the axioms' final conversion monotype $\type_s \rightsquigarrow \type_t$ with $\type_1 \rightsquigarrow \type_2$. Further, after applying the type substitution resulting from the unification to its conditions ($\overline{j_i:\convmono}$), these should consist only of ground types and must all be satisfied under $\imEnv$.

In order to prove the satisfiability of the conditions, the auxiliary judgment \textsc{Theorem} is used. Its specification resembles \textsc{Axiom}'s but it allows for the conversions to be satisfied by composing multiple conversion axioms.

The highlighted parts are important for the construction of the conversions but can be ignored for now.

\begin{figure}
  \begin{flushleft}
  \namedRuleform{ \convax{\imEnv}{\type_1}{\type_2}{\term}}
                {Axiom Conversion Judgment}
\end{flushleft}

\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}

\inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \convax{\imEnv}{\type_1}{\type_2}{\lambda \tmVar. \tmVar} }
  \\[5mm]
  \inferrule*[right=Axiom]
  {
    (k : \forall \overline{\tyVar}.\overline{j_i:\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_s \rightsquigarrow \type_t=\term) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type}]\type_s
    \\
    \type_2 = [\overline{\tyVar}\mapsto \overline{\type}]\type_t
    \\
    \forall\; i \;:\;(\convthr{\imEnv}{[\overline{a} \mapsto \overline{\type}]\type_{s_i}}{[\overline{a} \mapsto \overline{\type}]\type_{t_i}}{\term_i})
    \\
    \forall i . ftyvsOf([\overline{a} \mapsto \overline{\type}]\type_{s_i}) = ftyvsOf([\overline{a} \mapsto \overline{\type}]\type_{t_i}) = \emptyset
  }
  { \convax{\imEnv}{\type_1}{\type_2}{[\overline{j_i \mapsto \term_i}]\term}}
  \end{array}
  \]
  \\[5mm]
    \begin{flushleft}
  \namedRuleform{ \convthr{\imEnv}{\type_1}{\type_2}{\term}}
                {Theorem Conversion Judgment}
    \end{flushleft}
    \[
    \begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
  \inferrule*[right=Theorem]
  {
    (k : \forall \overline{\tyVar}.\overline{j_i:\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_s \rightsquigarrow \type_t=\term) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type}]\type_s
    \\
    \type_3 = [\overline{\tyVar}\mapsto \overline{\type}]\type_t
    \\
    \forall\; i \;:\;(\convthr{\imEnv}{[\overline{a} \mapsto \overline{\type}]\type_{s_i}}{[\overline{a} \mapsto \overline{\type}]\type_{t_i}}{\term_i})
    \\
    \forall i . ftyvsOf([\overline{a} \mapsto \overline{\type}]\type_{s_i}) = ftyvsOf([\overline{a} \mapsto \overline{\type}]\type_{t_i}) = \emptyset
    \\
    \convthr{\imEnv}{\type_3}{\type_2}{\term_{rest}}
  }
{ \convthr{\imEnv}{\type_1}{\type_2}{\lambda x. \term_{rest} \; ([\overline{j_i \mapsto \term_i}]\term \;x)}}
  \end{array}
\]  
  \caption{Implicit Conversion Judgment}
  \label{ICJ}
\end{figure}

\subsubsection{Finding the Dominator}
The fact that \textit{being able to implicitly convert} is a reflexive relation between types follows immediately from the \textsc{Unification} rule in \fref{ICJ}. Together with the definition of dominator, this implies that for any environment, the dominator of a single conversion constraint $\convX{\imEnv}{\type}{a}$ is $\type$. This reasoning also applies if the source types of all the constraints are the same.

In more complex cases, the dominator is resolved by first computing, for each constraint $\convX{\imEnv_i}{\type_{i}}{a}$, the set $R_i$ of types reachable from $\type_i$ under the implicit environment $\imEnv_i$ ($\type_{i} \subseteq R_i$, see Subsection \ref{reachability}). The intersection of all $R_i$ constitutes the set $D$ of possible dominators: for a type $\type_d$ to be in $D$, it must be reachable from all the types $\overline{\type_{i}}$. Then, the set $P$ of all paths from each $\type_{i}$ to each type $\type_d \in D$ is computed. If there is a dominator, it must be the (the only type) present in all paths in $P$ so it suffices to compute the intersection.

\textbf{CAN THIS EVEN HAPPEN? If there is a constraint of the form $\convX{\imEnv_k}{\type_s}{\type_t}$, with $a$ a type variable of $\type_t$, this constraint should be taken into account when instantiating $a$. The types reachable from $\type_s$ are computed and unified with $\type_t$ to get the possible values for $a$ from this constraint ($R_k$). Afterwards, the paths from $\type_s$ to the types $\type_{t_d}$ ($\type_t$ in which $a$ was substituted by the elements $\type_d \in D$) would be analyzed together with the paths in $P$.}

If, in any of the fore mentioned cases, it is not possible to compute the dominator, since either $D$ is empty and no conversion exists or the source program is ambiguous and there is no \textit{best} choice of the type to instantiate a type variable with.

\textbf{The implementation provided with this thesis does not fully support this approach: constraints in which $\type_t$ contains a type variable $a$ are not considered when instantiating $a$. We first go through the constraints looking for a type variable in the right hand side of the conversion monotype. Upon finding one, $\tyVar$, we collect the left hand sides of all the constraints with $a$ as the right hand side. We then compute the dominator of this set of constraints. Nonetheless, this has the desired behavior for all the constraints in which $\tyVar$ is (part of) the left hand side.}

\section{Constructing the Conversion}
\label{constructing}
Once all the type variables in the conversion constraints have been substituted, it is time to assess their entailability by constructing the conversions. This process is central for the elaboration of the program since it yields the appropriate terms to substitute the place holding variables with. Furthermore, during this process the design decision of rejecting ambiguous programs is again enforced.

For each constraint $\convX{\imEnv_i}{\type_{s}}{\type_{t}}$ (the conversion monotype $\type_{s}\rightsquigarrow \type_{t}$ is now ground) all conversion paths (according to \ref{paths}) from $\type_{s}$ to $\type_{t}$ are computed. If multiple paths are found, the program is ambiguous and as such rejected. Otherwise there is only one way to compose the conversion axioms into a conversion path.

However, according to the specification in \fref{ICJ}, there may exist multiple ways in which the axioms' conditions are satisfied. Since these conditions determine the converting expression introduced in the program at compile time, entailing them in different ways would result in different converting expressions to be used in the elaborated program and ultimately in distinct elaborated programs.

Subsection \ref{constr} discusses an algorithm to construct the implicit conversion that yields the appropriate converting expression and enforces that if any condition along the converting path can be entailed in more ways than one, the corresponding axiom will be unavailable. Since there was only one path, it will fail to compute it and the program will be rejected, as determined in Chapter~\ref{cha:$}.

\section{Computations}
\label{computations}
This section discusses in detail the computations referenced in \ref{sc:cc} and \ref{constructing}, in the order they appear in the text.

\subsection{Reachability}
\label{reachability}
To compute the types reachable from a given type $\type$ under a given implicit environment $\imEnv$, a queue (initially consisting of $\type$) and an accumulator (initially empty) are used. The applicability of each conversion axiom to the head of the queue $\type_{head}$ is checked and, if it is applicable, the types $\overline{\type_i}$ the axiom can convert $\type_{head}$ to are added to the back of the queue. To check the applicability and compute the $\overline{\type_i}$'s the axiom tester (\ref{onestep}) \textbf{ which uses the \textsc{Axiom Conversion Judgment} of \fref{ICJ}} is used.

Once all the axioms have been tried, the head of the queue is moved to the accumulator and the process restarts with the current queue and the entire environment $\imEnv$. When there are no more elements in the queue, all the reachable types are in the accumulator.

\subsection{Computing the Paths}
\label{paths}
To compute all the paths from a source type $\type_s$ to a target type $\type_t$, an algorithm with an accumulator and a queue $Q$ of paths under construction is used. Initially, the accumulator is empty and $Q$ consists of one path with a single type $\type_s$. The iterative step is to pick the last type $\type_{j_{n_j}}$ on the first path ($p_j = \type_{j_1}\to ... \to \type_{j_{n_j}}$) of the queue and and check if it is equal to $\type_t$. If so, $p_j$ is added to the accumulator. Otherwise, the axiom tester (\ref{onestep}) is applied to $\type_{j_{n_j}}$ for every axiom in the implicit environment. For each returned type $\type_i$ not present in $p_j$, a path $p_{j_i} = \type_{j_1}\to ... \to \type_{j_{n_j}} \to \type_i$ is added to the end of $Q$. After trying every conversion axiom in the implicit environment, $p_j$ is deleted from $Q$ and the process resumes with the new list of paths under construction. When $Q$ becomes empty, the algorithm stops and the accumulator is returned.

\subsection{Axiom Tester}
\label{onestep}
To be able to assess if a conversion axiom is applicable to some given ground type $\type$ and compute the types it can implicitly convert $\type$ into, multiple cases must be considered.

 If the conversion axiom $\term : \forall \overline {\tyVar} . \overline{(j_i : \convmono_i)} \Rightarrow \type_s \rightsquigarrow \type_t$ does not contain type variables, it suffices to check if $\type_s$ equals $\type$ and if the conditions are entailed. If so, $i$ is able to convert $\type$ (only) to $\type_t$. More generally, if it is possible to unify $\type_s$ with $\type$ resulting in a type substitution $\Theta$ and applying $\Theta$ to $i$ causes all type to be ground, the same approach is taken.

 However, there are more complex cases. Take this conversion axiom presented in Chapter~\ref{cha:5}: $\lambda \tmVar . map\;j\;\tmVar: j: a \rightsquigarrow b \Rightarrow [a] \rightsquigarrow [b] $. We clearly can not ignore this conversion axiom, nor can we blindly try different instantiations of $b$. 

 In such axioms $\term : \forall \overline {\tyVar} . \overline{(j_i : \convmono_i)} \Rightarrow \type_s \rightsquigarrow \type_t$, if it is possible to unify $\type_s$ with $\type$ resulting in a type substitution $\theta$, then $\theta$ is applied to the conditions. Afterwards, a reachability graph is constructed to determine the types $\overline{\type_{i_j}}$ that are possible choices for the remaining type variables $\overline{a_i}$. As such, the axiom can implicitly convert $\type$ to  $([\overline{\tyVar_i} \mapsto \overline{\type_{i_j}}]\circ \Theta)\type_t$, for each appropriate tuple of $\overline{\type_{i_j}}$.



\subsection{Constructing the Conversion Expression}
\label{constr}
To compute the converting expressions necessary to elaborate the source program, the user-provided converting expressions (introduced in the conversion axioms) are used.

In order to construct the conversion that satisfies some constraint $\convX{\imEnv_1}{\type_s}{\type_t}$, we compute a converting path from $\type_s$ to $\type_s$ almost as described in \ref{paths}.

However, a variant (discussed below) of the axiom tester is now used that ensures the conditions can only be entailed in one way and that returns the converting expression associated to the axiom, as highlighted in \fref{ICJ}.

For each conversion constraint $\convX{\imEnv_i}{\type_{s}}{\type_{t}}$, a converting expression under construction is kept. It is initiated to the identity function ($\lambda x. x$) and, for every necessary conversion axiom $\convax{\imEnv}{\type_1}{\type_2}{\term}$ in the converting path, the lambda abstraction is updated to $\lambda x . (\term \;\;body)$.

Upon reaching the target of the conversion constraint, the converting expression $exp$ is no longer under construction and will replace the term variable present in the conversion constraint. The term $exp$ will be of the form $\lambda x . (\term_n ... (\term_1\;\;x)...)$ and have type $\type_s \to \type_t$, as required.

\subsubsection{Unambiguous Axiom Tester}

The Axiom Tester discussed in Section \ref{onestep} allows for the conditions in a conversion axiom to be entailed in multiple ways. This is the desired behavior for the algorithms that use it:  not using it to compute the paths could cause the elaboration of a source program that should be rejected due to its ambiguity: consider  $\convX{\imEnv}{\type_s}{\type_t}$. Suppose there are two axioms capable of converting $\type_s$ to $\type_t$: \textit{ax1} and \textit{ax2}. The former has no conditions whereas the latter has a condition that, under $I$, can be entailed in two different ways. Not allowing ambiguity in the conditions would mean $ax2$ would be disregarded and $ax1$ used, which is undesirable since this program should be considered ambiguos because this constraint can be entailed in not one but rather in three different ways.

However, allowing conditions to be entailed in multiple ways is not desirable for constructing the conversions. If $\term :\forall \overline{a} . \overline{j_i : \convmono} \Rightarrow \convmono$ has conditions that can be entailed in more than one ways, the $j_i$ can be substituted in $\term$ by multiple terms (resulting in multiple elaborated programs).

Changing this behavior is easy to implement: for each condition, the algorithm to compute the possible paths (Section~\ref{paths}, with the unambiguous axiom tester instead of the axiom tester) is ran and, if there is only one path from the source to the target speficied by the constraint, the constraint is entailed by the implicit environment.

Note that, since the size of the types in the conditions is strictly smaller to the size of the types in the final conversion monotype, the process of entailing each constraint is bound to terminate. For cases in which there are type variables on the left hand side of the conditions, the version described in Section~\ref{opt} is used instead.

Furthermore, the unambiguous axiom tester returns the appropriate converting expression to use during elaboration. As such, the place holding variables in the converting expression must be substituted by the expressions specified in the (unique) conversion axiom in the environment that satisfies each condition.

\subsection{Optimizations}
\label{opt}

It is clear that some parts of the process described can be optimized in an implementation: instead of computing the reachable types and the the possible paths, it is possible to compute the reachability graphs and get the necessary information for both these steps.

Notice how easily the computation of the paths in \ref{paths} can be modified to compute all the conversion paths (the reachability graph) from a given type: it suffices to eliminate the equality check of the final type in a path against the (now non-existing) target type and take every partial path $p_j = \type_{j_1}\to ... \to \type_{j_i}$ from each path $p_j = \type_{j_1}\to ... \to \type_{j_i} \to ... \to \type_{j_{final}}$ in the accumulator.

Further, the ambiguity check discussed in the second paragraph of \ref{constructing} could be moved (for all the constraints involved in a ``finding the dominator step'') to this computation: instead of only keeping the types on the paths, the computation of the paths could be modified to store the axioms used at each step of the way. After taking the partial paths, it could be easily verified whether that two paths exist to the same type $\type_{amb}$. In that case, not only would the conversion to $\type_{amb}$ be ambiguous as would for any type for which there is a path containing $\type_{amb}$.

As discussed in \ref{constr}, the constructing the conversion step deals with ambiguity due to conditions being entailed in multiple ways. Finally, if the axioms used are stored, as just described, constructing the conversion could also be made more efficient.



\section{Example}
This section focuses on solving the constraints generated by the program in \fref{complex5}. Since this program consists of nested applications, the equality constraint that arises from the type annotation will be disregarded, until further notice, in order to better showcase the graph-based constraint solver.
\subsection{Substituting Type Variables}
Recall that the equality constraints $E$ generated by Example \ref{complex5} were \{$Float\to \text{CHF} \sim b_1 \to b_2, a \to a \to (\text{Wallet} \; a) \sim b_3 \to b_4$, $Float \to \text{DKK} \sim b_5 \to b_6$, $b_4 \sim b_7 \to b_8$\} and the generated conversion constraints $Y$ were \{$\convX{\imEnv_1}{Float}{b_1},\; \convX{\imEnv_1}{b_2}{b_3}$,\; $\convX{\imEnv_2}{Int}{b_5}$,\; $\convX{\imEnv_1}{b_6}{b_7}$ \}.

Performing unification on $E$ results in the substitution $\Theta= [b_1 \mapsto Float, \;b_2 \mapsto \text{CHF}, \;b_3 \mapsto a, \;b_4 \mapsto a \to \text{Wallet }a, \;b_5 \mapsto Float, \;b_6 \mapsto \text{DKK},\;b_7 \mapsto a,\;b_8 \mapsto \text{Wallet }a]$. The application of $\Theta$ to $Y$ yields the updated constraints $Y' = \{(j_1,\convX{\imEnv_1}{Float}{Float})$, $(j_2,\convX{\imEnv_1}{\text{CHF}}{a})$, $(j_3,\convX{\imEnv_2}{Int}{Float}),\;(j_4,\convX{\imEnv_1}{\text{DKK}}{a}) \}$.

This example results in a almost trivial graph presented in \fref{6a}. Both constraints are indexed by the environment $\imEnv_1 = \{\lambda \tmVar . K_{\text{EUR}}\; 28.0 : \text{DKK} \rightsquigarrow \text{EUR}, \;\lambda \tmVar . K_{\text{EUR}}\; 14.1 : {\text{CHF}} \rightsquigarrow {\text{EUR}},\; {\lambda \tmVar . K_{\text{USD}}\; 1.41} : {\text{EUR}} \rightsquigarrow {\text{USD}},\; (\lambda \tmVar. case\;\tmVar\; of\;K_{\text{Wallet}}\;x_1\;x_2 \to K_{\text{Wallet}} (j\;x_1)\;(j\;x_2)) :(\forall a, b . j : a \rightsquigarrow b \Rightarrow \text{Wallet}\;a\rightsquigarrow \text{Wallet}\;b)\}$ (in \fref{6b}).
\begin{figure}
  \centering
  \begin{subfigure}{.30\textwidth}
    \centering
    \includegraphics[width=\linewidth]{6a}
    \caption{Plot of the constraints with type variables}
    \label{6a}
  \end{subfigure}
  \begin{subfigure}{.40\textwidth}
    \centering
    \includegraphics[width=\linewidth]{6b}
    \caption{The implicit environment $\imEnv_1$}
    \label{6b}
  \end{subfigure}
\end{figure}


Following \ref{dominator}, the computation of the types reachable from CHF and from DKK  results in, respectively, \{ CHF, EUR, USD \} and \{DKK, EUR, USD\}. The intersection of these sets is \{ EUR, USD\} and, as such all paths from CHF and from DKK to both EUR and USD must be computed. EUR is the dominator since it is present in these paths and, as such, should replace $a$ in all the conversion constraints.
\subsection{Constructing the Conversion}
Entailing the conversion contraint and constructing the converting expression can (and should) be handled simultaneously. The first constraint $(j_1,\convX{\imEnv_1}{Float}{Float})$ is trivially entailed. As such $j_1$ should be replaced by the identity function.

Regarding the conversion $(j_2,\convX{\imEnv_1}{\text{CHF}}{\text{EUR}})$, note that only one conversion axiom is applicable to the type CHF: . This axiom has no conditions, so it is applicable and can not introduce ambiguity by itself. The set of paths under construction becomes CHF $\to$ EUR and is bound to the converting expression $\lambda \tmVar . K_{\text{EUR}}\; 14.1 $. Because EUR is the target type of the constraint, this path is not extended; and since it is the only path under construction the implicit conversion is not ambiguous. Hence, $j_2$ will be replaced by $\lambda \tmVar . K_{\text{EUR}}\; 14.1 $.

The constraint $(j_3,\convX{\imEnv_2}{Int}{Float})$ and $(j_4,\convX{\imEnv_1}{\text{DKK}}{EUR})$ are treated in a completely identical manner. The place-holders $j_3$ and $j_4$ are replaced by, respectively, $\lambda \tmVar.3.1415$ and $\lambda \tmVar . K_{\text{EUR}}\; 28.0$.

Applying these substitutions to the partially elaborated program (shown in \fref{partialElab}) results in the fully elaborated program presented in \fref{fullyElab}.
\begin{figure}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;\text{EUR}=K_{\text{EUR}}\;Float;\\
  data\;\text{CHF}=K_{\text{EUR}}\;Float;;\\
  data\;\text{DKK}=K_{\text{DKK}}\;Float;\\
  data\;\text{USD}=K_{\text{USD}}\;Float;\\
  data\;\text{Wallet}\;\tyVar=K_{\text{Wallet}}\; \tyVar \; \tyVar;\\[3mm]
  (K_{\text{Wallet}}\;((\lambda \tmVar . K_{\text{EUR}}\; 14.1)\;(K_{\text{CHF}}\;((\lambda \tmVar . \tmVar)\; 5.25))))\;((\lambda \tmVar . K_{\text{EUR}}\; 28.0)\; (K_{\text{DKK}}\;((\lambda \tmVar.3.1415)\;1)))) 

\end{array}
\]
\caption{Partial elaboration of the TrIC program in Example \ref{complex5}.}
\label{fullyElab}
\end{figure}

\textbf{SHOW the construction of a decent conversion expression}
