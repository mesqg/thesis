\chapter{Constraint Solving}
\label{cha:6}

Chapter~\ref{cha:5} discussed the collection of the constraints generated by a TrIC program as well as its partial elaboration to a subset of TrIC without implicit conversions. It remains to be assessed whether the generated constraints are entailable. If so, it must be possible to complete the elaboration by substituting the place-holding variables by the appropriate converting expressions, so that the corresponding System F program type-checks. If not, or if the source program can be elaborated in multiple ways, it must be rejected.

This chapter discusses the approach taken to check the entailability of the constraints (involving a graph-based solver), the detection of ambiguous programs and the strategy to compute the converting expressions to be inserted in the code (Sections \ref{sc:cc} and \ref{constructing}). Section \ref{computations} discusses the necessary computations for the aforementioned purposes. The chapter ends with an example showcasing constraint solving from top to bottom and the full elaboration of a program (Section \ref{6.4}).


\section{Instantiating Type Variables}
\label{sc:cc}
The first step towards solving all the collected constraints is to perform unification (exactly as in \fref{unification}) on the equality constraints. Unless this process fails, in which case the program is immediately rejected, it yields the type substitution $\Theta$ necessary to entail the equality constraints. At this point only the conversion constraints resulting of applying $\Theta$ to the original constraints need to be entailed.
\subsection{Motivating Example}
Consider again the program presented in Example \ref{eg4}. Neglect the lack of annotation for the sake of exposing corner cases regarding the entailment process of the generated constraints without resorting to overly complex programs.

After solving the equality constraints and applying the resulting type substitution to conversion constraints, these become: \{$\convX{\imEnv_1}{Float}{Float}$, $\convX{\imEnv_1}{Float}{Float}$, $\convX{\imEnv_1}{\text{DKK}}{a}, \convX{\imEnv_1}{\text{CHF}}{a}$ \}.

Assuming $\imEnv_1 = \{e_1 : \text{DKK} \rightsquigarrow \text{EUR}, \;e_2 : \text{CHF} \rightsquigarrow \text{EUR}\}$, it is clear that it is not possible to convert CHF to DKK nor the other way around under $I_1$; however, both are convertible to EUR. If the conversion constraints were to be solved sequentially, $a$ would be substituted by either DKK or by CHF, depending on which is considered first, thus leading to the rejection of a sensible program (according to the Chapter \ref{cha:4}'s definition of sensible).

Consequently, this section develops a graph-based constraint solver that considers multiple conversions in order to instantiate a type variable and accepts programs as long as there is always a best type to substitute a type variable with, \textit{i.e.}, as long as there is a dominator for each set of related constraints.

\subsection{Building the Graph}
\label{graph}
After applying the substitutions, resulting from unification on the equality constraints, to the conversion constraints, the next goal is to substitute the remaining type variables by ground types. The constraints $\overline{\convX{\imEnv_i}{\type_{s_i}}{\type_{t_i}}}$ with remaining type variables are plotted in a graph, with nodes for each monotype and directed edges representing the need to convert from $\type_{s_i}$ to the other $\type_{t_i}$. Note that these edges are indexed by the implicit environments $\imEnv_i$ specified by each constraint, and it may be the case that multiple edges with the same direction exist between the same types.

To construct the graph, a first conversion constraint $\convX{\imEnv_1}{\type_{s_1}}{\type_{t_1}}$ is picked and, if it contains type variables, two nodes ($\type_{s_1}$ and $\type_{t_1}$) are created and joined by a directed edge indexed by the implicit environment $I_1$. Conversions are then sequentially handled and, if either of its types is a type variable already in the graph, the edges are built from there. Nodes that are not type variables are connected to the rest of the graph by exactly one edge (either incoming or outgoing), so that there is a clear order in which to entail the conversion constraints. This implies multiple nodes may be identical. 

Upon encountering a constraint $\convX{\imEnv_i}{\type_{s_i}}{\type_{t_i}}$ such that either $\type_{s_i}$ or $\type_{t_i}$ contains, but is not, a type variable $a$ already in the graph, we sort the components in the graph according to a partial order to determine which to address first. Whenever $\type_s$ contains $a$, its component should be handled after the one that contains $a$.

For each component, its sources are known to be ground types. Type variables in the sources of the first components to be handled could only occur due to top-level lambda abstractions. Solving the equality constraint involving the annotated type ensures their replacement by ground types. Type variables in the sources of other components are substituted by ground types before considering that component due to the partial order enforced.

The approach is to follow the edges of the graph, starting from the sources. Upon encountering a type variable $a$, all the constraints that contain $a$ in the second part of their conversion monotypes are collected. Then the \textit{dominator} (\ref{dominator}) of this set of conversion constraints is computed and substitutes $a$ everywhere. The process continues by following the edges towards the sinks. The type variables encountered are necessarily the second part of the conversion monotype, since the sources are ground and we only move towards the sinks after the types closer to the sources have been made ground.

\subsection{The Dominator}
\label{dominator}
As discussed in Chapter~\ref{cha:4}, the \textit{dominator}, of a set of conversion constraints $S=\overline{\convX{\imEnv_i}{\type_{s_i}}{a}}$, with $\overline{\type_{s_i}}$ ground types, is the type $\type_{dominator}$ to which all $\type_{s_i}$'s can convert to and that, for any other reachable type $\type_d$ such that  all $\type_{s_i}$'s can convert to $\type_d$, any conversion from any $\type_{s_i}$ to $\type_d$ can be decomposed into a conversion from $\type_{s_i}$ to $\type_{dominator}$ and another from $\type_{dominator}$ to $\type_d$.

To formalize this notion of \textit{being able to implicitly convert}, \fref{ICJ} introduces two judgments: \textsc{Theorem Conversion Judgment} specifies the existence of an implicit conversion between two types; \textsc{Axiom Conversion Judgment} is stronger as it states that only one conversion axiom is needed to implicitly convert from the source type to the target type.


\subsubsection{Conversion Judgments}
\label{susec}
The axiom conversion judgment ($\convax{\imEnv}{\type_1}{\type_2}{\term}$), formalized in \fref{ICJ} states that there is a conversion axiom in $\imEnv$ that can be used to implicitly convert from $\type_1$ to $\type_2$.

For a conversion axiom $\term : \forall \overline{\tyVar}.\overline{j_i:\convmono} \Rightarrow \type_s \rightsquigarrow \type_t$, to be applicable to implicitly convert $\type_1$ to $\type_2$, there must be a substitution $\Theta$ that unifies the axioms' final conversion monotype $\type_s \rightsquigarrow \type_t$ with $\type_1 \rightsquigarrow \type_2$, grounds all type variables and entails the conditions ($\overline{j_i:\convmono}$).

In order to prove the satisfiability of the conditions, the auxiliary judgment \textsc{Theorem} is used. Its specification resembles \textsc{Axiom}'s but it allows for the conversions to be satisfied by composing multiple conversion axioms.

The highlighted parts are important for the construction of the conversions but can be ignored for now.
\begin{figure}
  \begin{flushleft}
  \namedRuleform{ \convax{\imEnv}{\type_1}{\type_2}{\term}}
                {Axiom Conversion Judgment}
\end{flushleft}

\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}

\inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \convax{\imEnv}{\type_1}{\type_2}{\lambda \tmVar. \tmVar} }
  \\[5mm]
  \inferrule*[right=Axiom]
  {
    (\term : \forall \overline{\tyVar}.\overline{j_i:\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_s \rightsquigarrow \type_t) \in \imEnv
    \\
    \exists \Theta : \type_1 = \Theta\type_s
    \\
    \type_2 = \Theta\type_t
    \\
    \forall\; i \;:\;(\convthr{\imEnv}{\Theta\type_{s_i}}{\Theta\type_{t_i}}{\term_i})
    \\
    \forall i . ftyvsOf(\Theta\type_{s_i}) = ftyvsOf(\Theta\type_{t_i}) = \emptyset
  }
  { \convax{\imEnv}{\type_1}{\type_2}{[\overline{j_i \mapsto \term_i}]\term}}
  \end{array}
  \]
  \\[5mm]
    \begin{flushleft}
  \namedRuleform{ \convthr{\imEnv}{\type_1}{\type_2}{\term}}
                {Theorem Conversion Judgment}
    \end{flushleft}
    \[
    \begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
      \inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \overline{\type};\convthi{\imEnv}{\type_1}{\type_2}{[fv(\type_1)\mapsto \overline{\type_{1i}}] \circ [fv(\type_2)\mapsto \overline{\type_{2i}}]}{\lambda \tmVar. \tmVar} }
\\[5mm]
  \inferrule*[right=Theorem]
  {(\term : \forall \overline{\tyVar}.\overline{j_i:\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_s \rightsquigarrow \type_t) \in \imEnv
    \\
    \exists \Theta : \type_1 = \Theta\type_s
    \\
    \type_3 = \Theta\type_t
    \\
    \convthr{\imEnv}{\type_3}{\type_2}{\term_{rest}}
        \\
        \forall i . ftyvsOf(\Theta(\type_{s_i})) = ftyvsOf(\Theta(\type_{t_i})) = \emptyset
        \\
    \forall\; i \;:\;(\convthr{\imEnv}{\Theta(\type_{s_i})}{\Theta(\type_{t_i})}{\term_i})
         }
  { \convthr{\imEnv}{\type_1}{\type_2}{\lambda x. \term_{rest} \; ([\overline{j_i \mapsto \term_i}]\term \;x)}}
  
  \end{array}
\]  
  \caption{\textbf{Declarative version (what i think should be)}}
  \label{ICJ2}
\end{figure}


\begin{figure}
  \begin{flushleft}
  \namedRuleform{ \convax{\imEnv}{\type_1}{\type_2}{\term}}
                {Axiom Conversion Judgment}
\end{flushleft}

\[
\begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}

\inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \convax{\imEnv}{\type_1}{\type_2}{\lambda \tmVar. \tmVar} }
  \\[5mm]
  \inferrule*[right=Axiom]
  {
    (\term : \forall \overline{\tyVar}.\overline{j_i:\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_s \rightsquigarrow \type_t) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type}]\type_s
    \\
    \type_2 = [\overline{\tyVar}\mapsto \overline{\type}]\type_t
    \\
    \forall\; i \;:\;(\convthr{\imEnv}{[\overline{a} \mapsto \overline{\type}]\type_{s_i}}{[\overline{a} \mapsto \overline{\type}]\type_{t_i}}{\term_i})
    \\
    \forall i . ftyvsOf([\overline{a} \mapsto \overline{\type}]\type_{s_i}) = ftyvsOf([\overline{a} \mapsto \overline{\type}]\type_{t_i}) = \emptyset
  }
  { \convax{\imEnv}{\type_1}{\type_2}{[\overline{j_i \mapsto \term_i}]\term}}
  \end{array}
  \]
  \\[5mm]
    \begin{flushleft}
  \namedRuleform{ \overline{\type};\convthi{\imEnv}{\type_1}{\type_2}{\Theta}{\term}}
                {Theorem Conversion Judgment}
    \end{flushleft}
    \[
    \begin{array}{@{\hspace{0mm}}c@{\hspace{0mm}}}
      \inferrule*[right=Unification]
  {
  [fv(\type_1)\mapsto \overline{\type_{1i}}]\type_1=[fv(\type_2)\mapsto \overline{\type_{2i}}]\type_2
  }
  { \overline{\type};\convthi{\imEnv}{\type_1}{\type_2}{[fv(\type_1)\mapsto \overline{\type_{1i}}] \circ [fv(\type_2)\mapsto \overline{\type_{2i}}]}{\lambda \tmVar. \tmVar} }
\\[5mm]
  \inferrule*[right=Theorem]
  {(\term : \forall \overline{\tyVar}.\overline{j_i:\type_{s_i} \rightsquigarrow \type_{t_i}} \Rightarrow \type_s \rightsquigarrow \type_t) \in \imEnv
    \\
    \type_1 = [\overline{\tyVar}\mapsto \overline{\type}]\type_s
    \\
    \type_3 = [\overline{\tyVar}\mapsto \overline{\type}]\type_t
    \\
    \type_3 \notin \overline{\type}\\
    \overline{\type},\type_1;\convthi{\imEnv}{\type_3}{\type_2}{\Theta}{\term_{rest}}
        \\
        \forall i . ftyvsOf(\Theta([\overline{a} \mapsto \overline{\type}]\type_{s_i})) = ftyvsOf(\Theta([\overline{a} \mapsto \overline{\type}]\type_{t_i})) = \emptyset
        \\
    \forall\; i \;:\;(\bullet;\convthi{\imEnv}{\Theta([\overline{a} \mapsto \overline{\type}]\type_{s_i})}{\Theta([\overline{a} \mapsto \overline{\type}]\type_{t_i})}{\Theta_i}{\term_i})
         }
  { \overline{\type};\convthi{\imEnv}{\type_1}{\type_2}{\overline{\Theta_i} \circ \Theta \circ [\overline{a} \mapsto \overline{\type}]}{\lambda x. \term_{rest} \; ([\overline{j_i \mapsto \term_i}]\term \;x)}}
  
  \end{array}
\]  
  \caption{Implicit Conversion Judgment}
  \label{ICJ}
\end{figure}

\subsubsection{Finding the Dominator}
The fact that \textit{being able to implicitly convert} is a reflexive relation between types follows immediately from the \textsc{Unification} rule in \fref{ICJ}. Together with the definition of dominator, this implies that for any environment, the dominator of a single conversion constraint $\convX{\imEnv}{\type}{a}$ is $\type$. This reasoning also applies if the source types of all the constraints are the same.

In more complex cases, the dominator of a set of conversion constraints whose target is the same type variable $\overline{\convX{\imEnv_i}{\type_{i}}{a}}$ is resolved by first computing, for each constraint $\convX{\imEnv_i}{\type_{i}}{a}$, the set $R_i$ of types reachable from $\type_i$ under the implicit environment $\imEnv_i$ ($\type_{i} \subseteq R_i$, see Subsection \ref{reachability}). The intersection of all $R_i$ constitutes the set $D$ of possible dominators: for a type $\type_d$ to be in $D$, it must be reachable from all the types $\overline{\type_{i}}$. Then, the set $P$ of all paths from each $\type_{i}$ to each type $\type_d \in D$ is computed. If there is a dominator, it must be the (the only type) present in all paths in $P$ so it suffices to compute the intersection.

If there is a constraint of the form $\convX{\imEnv_k}{\type_s}{\type_t}$, with $a$ a type variable of $\type_t$, this constraint could also be taken into account when instantiating $a$. The types reachable from $\type_s$ are computed and unified with $\type_t$ to get the possible values for $a$ from this constraint ($R_k$). Afterwards, the paths from $\type_s$ to the types $\type_{t_d}$ ($\type_t$ in which $a$ was substituted by the elements $\type_d \in D$) would be analyzed together with the paths in $P$. However, the implementation provided with this thesis does not support this approach: constraints in which $\type_t$ contains a type variable $a$ are not considered when instantiating $a$, in order to avoid an explosion on the complexity of dominator step. Finding a tractable approach that takes such constraints into account s left as future work.

%We first go through the constraints looking for a type variable in the right hand side of the conversion monotype. Upon finding one, $\tyVar$, we collect the left hand sides of all the constraints with $a$ as the right hand side. We then compute the dominator of this set of constraints. Nonetheless, this has the desired behavior for all the constraints in which $\tyVar$ is (part of) the left hand side.}

If, in any of the fore mentioned cases, it is not possible to compute the dominator, since either $D$ is empty and no conversion exists or the source program is ambiguous and there is no \textit{best} choice of the type to instantiate a type variable with.



\section{Constructing the Conversion}
\label{constructing}
Once all the type variables in the conversion constraints have been substituted, it is time to assess their entailability by constructing the conversions. This process is central for the elaboration of the program since it yields the appropriate terms to substitute the place holding variables with. Furthermore, during this process the design decision of rejecting ambiguous programs is again enforced.

Each constraint $\convX{\imEnv_i}{\type_{s}}{\type_{t}}$ (the conversion monotype $\type_{s}\rightsquigarrow \type_{t}$ is now ground) is considered. If the types $\type_{s}$ and $\type_{t}$ are equal, the constraint is trivially entailed and we move on to the next one. This ensures that programs that do not require implicit conversions will not be affected. Otherwise, all the conversion paths (according to \ref{paths}) from $\type_{s}$ to $\type_{t}$ are computed. If multiple paths are found, the program is ambiguous and as such rejected. Otherwise there is only one way to compose the conversion axioms into a conversion path.

However, according to the specification in \fref{ICJ}, there may exist multiple ways in which the axioms' conditions are satisfied. Since these conditions determine the converting expression introduced in the program at compile time, entailing them in different ways would result in different converting expressions to be used in the elaborated program and ultimately in distinct elaborated programs.

Subsection \ref{constr} discusses an algorithm to construct the implicit conversion that yields the appropriate converting expression and enforces that if any condition along the converting path can be entailed in more ways than one, the corresponding axiom will be unavailable. Since there was only one path, it will fail to compute it and the program will be rejected, as determined in Chapter~\ref{cha:4}.

\subsection{Constructing the Conversion Expression}
\label{constr}
To compute the converting expressions necessary to elaborate the source program, the user-provided converting expressions (introduced in the conversion axioms) are used.

In order to construct the conversion that satisfies some constraint $\convX{\imEnv_1}{\type_s}{\type_t}$, we compute a converting path from $\type_s$ to $\type_s$ almost as described in \ref{paths}. Again, an exception is made in case $\type_{s}$ and $\type_{t}$ are the same: in that case, the converting expression is the identity function.

However, a variant (discussed below) of the axiom tester is now used that ensures the conditions can only be entailed in one way and that returns the converting expression associated to the axiom, as highlighted in \fref{ICJ}.

For each conversion constraint $\convX{\imEnv_i}{\type_{s}}{\type_{t}}$, a converting expression under construction is kept. It is initiated to the identity function ($\lambda x. x$) and, for every necessary conversion axiom $\convax{\imEnv}{\type_1}{\type_2}{\term}$ in the converting path, the lambda abstraction is updated to $\lambda x . (\term \;\;body)$.

Upon reaching the target of the conversion constraint, the converting expression $\term$ is no longer under construction and will replace the term variable present in the conversion constraint. The term $\term$ will be of the form $\lambda x . (\term_n ... (\term_1\;\;x)...)$ and have type $\type_s \to \type_t$, as required.

\subsubsection{Unambiguous Axiom Tester}
\label{uat}

The Axiom Tester discussed in Section \ref{onestep} allows for the conditions in a conversion axiom to be entailed in multiple ways. This is the desired behavior for the algorithms that use it:  not using it to compute the paths could cause typing a source program that should be rejected due to its ambiguity: consider  $\convX{\imEnv}{\type_s}{\type_t}$. Suppose there are two axioms capable of converting $\type_s$ to $\type_t$: \textit{ax1} and \textit{ax2}. The former has no conditions whereas the latter has a condition that, under $I$, can be entailed in two different ways. Not allowing ambiguity in the conditions would mean $ax2$ would be disregarded and $ax1$ used, which is undesirable since this program should be considered ambiguous because this constraint can be entailed in not one but rather in three different ways.

However, allowing conditions to be entailed in multiple ways is not desirable for constructing the conversions. If $\term :\forall \overline{a} . \overline{j_i : \convmono} \Rightarrow \convmono$ has conditions that can be entailed in more than one ways, the $j_i$ can be substituted in $\term$ by multiple terms (resulting in multiple elaborated programs).

It is straight forward to change this behavior: for each condition, the algorithm to compute the possible paths (Section~\ref{paths}, with the unambiguous axiom tester instead of the axiom tester) is ran and, if there is only one path from the source to the target specified by the constraint, the constraint is entailed by the implicit environment.

Note that, since the size of the types in the conditions is strictly smaller to the size of the types in the final conversion monotype, the process of entailing each constraint is bound to terminate. For cases in which there are type variables on the left hand side of the conditions, the version described in Section~\ref{opt} is used instead.

Furthermore, the unambiguous axiom tester returns the appropriate converting expression to use during elaboration. As such, the place holding variables in the converting expression must be substituted by the expressions specified in the (unique) conversion axiom in the environment that satisfies each condition.

\section{Computations}
\label{computations}
This section discusses in detail the computations referenced in Sections \ref{sc:cc} and \ref{constructing}, in the order they appear in the text.

\subsection{Reachability}
\label{reachability}
To compute the types reachable from a given type $\type$ under a given implicit environment $\imEnv$, a queue (initially consisting of $\type$) and an accumulator (initially empty) are used. The applicability of each conversion axiom to the head of the queue $\type_{head}$ is checked and, if it is applicable, the types $\overline{\type_i}$ the axiom can convert $\type_{head}$ to are added to the back of the queue. To check the applicability and compute the $\overline{\type_i}$'s the axiom tester (\ref{onestep}) which uses the \textsc{Axiom Conversion Judgment} of \fref{ICJ}.

Once all the axioms have been tried, the head of the queue is moved to the accumulator and the process restarts with the current queue and the entire environment $\imEnv$. When there are no more elements in the queue, all the reachable types are in the accumulator.

\subsection{Computing the Paths}
\label{paths}
To compute all the paths from a source type $\type_s$ to a target type $\type_t$, an algorithm with an accumulator and a queue $Q$ of paths under construction is used. Initially, the accumulator is empty and $Q$ consists of one path with a single type $\type_s$. The iterative step is to pick the last type $\type_{j_{n_j}}$ on the first path ($p_j = \type_{j_1}\to ... \to \type_{j_{n_j}}$) of the queue and check if it is equal to $\type_t$. If so, $p_j$ is added to the accumulator. Otherwise, the axiom tester (\ref{onestep}) is applied to $\type_{j_{n_j}}$ for every axiom in the implicit environment. For each returned type $\type_i$ not present in $p_j$, a path $p_{j_i} = \type_{j_1}\to ... \to \type_{j_{n_j}} \to \type_i$ is added to the end of $Q$. After trying every conversion axiom in the implicit environment, $p_j$ is deleted from $Q$ and the process resumes with the new list of paths under construction. When $Q$ becomes empty, the algorithm stops and the accumulator is returned. Note that, since the types added to each path must not already be present in the path, this approach avoids entering loops. As such, under the implicit environment shown in \fref{61}, the path from DKK to EUR will be correctly computed as DKK $\to$ CHF $\to$ EUR.
  \begin{figure}
    \centering
    \includegraphics[width=.2\linewidth]{61}
    \caption{Plot of the constraints with type variables. Both are indexed by $I_1$.}
    \label{61}
  \end{figure}


\subsection{Axiom Tester}
\label{onestep}
To be able to assess if a conversion axiom is applicable to some given ground type $\type$ and compute the types it can implicitly convert $\type$ into, multiple cases must be considered.

 If the conversion axiom $\term : \forall \overline {\tyVar} . \overline{(j_i : \convmono_i)} \Rightarrow \type_s \rightsquigarrow \type_t$ does not contain type variables, it suffices to check if $\type_s$ equals $\type$ and if the conditions are entailed. If so, $i$ is able to convert $\type$ (only) to $\type_t$. More generally, if it is possible to unify $\type_s$ with $\type$ resulting in a type substitution $\Theta$ and applying $\Theta$ to $i$ causes all type to be ground, the same approach is taken.

 However, there are more complex cases. Take this conversion axiom presented in Chapter~\ref{cha:5}: $\lambda \tmVar . map\;j\;\tmVar: j: a \rightsquigarrow b \Rightarrow [a] \rightsquigarrow [b] $. For such axioms $\term : \forall \overline {\tyVar} . \overline{(j_i : \convmono_i)} \Rightarrow \type_s \rightsquigarrow \type_t$, if it is possible to unify $\type_s$ with $\type$ resulting in a type substitution $\Theta_1$, then $\Theta_1$ is applied to the conditions and to $\type_t$. Afterwards, reachability graphs are constructed for each condition (the types $\type_{s_i}$ are ground by this point, due to the conditions specified in Section \ref{constraints}), to determine the types that are possible choices for the remaining type variables, \textit{i.e.}, such that the conditions are entailed. This results in (possibly) multiple  second substitutions, $\Theta_{i_2}$. As such, the axiom can implicitly convert $\type$ to  $(\Theta_{i_2} \circ \Theta_1)\type_t$, for each substitution $\Theta_{i_2}$. \textbf{explain why this ambiguity is harmless}.



\subsection{Optimizations}
\label{opt}

It is clear that some parts of the process described can be optimized in an implementation: instead of computing the reachable types and the possible paths, it is possible to compute the reachability graphs and get the necessary information for both these steps.

Notice how easily the computation of the paths in Section \ref{paths} can be modified to compute all the conversion paths (the reachability graph) from a given type: it suffices to eliminate the equality check of the final type in a path against the (now non-existing) target type and take every partial path $p_j = \type_{j_1}\to ... \to \type_{j_i}$ from each path $p_j = \type_{j_1}\to ... \to \type_{j_i} \to ... \to \type_{j_{final}}$ in the accumulator.

Further, the ambiguity check discussed in the second paragraph of Section \ref{constructing} could be moved (for all the constraints involved in ``finding the dominator step'') to this computation: instead of only keeping the types on the paths, the computation of the paths could be modified to store the axioms used at each step of the way. After taking the partial paths, it could be easily verified whether that two paths exist to the same type $\type_{amb}$. In that case, not only would the conversion to $\type_{amb}$ be ambiguous as it would also be for any type for which there is a path containing $\type_{amb}$.

As discussed in Section \ref{constr}, constructing the conversion deals with ambiguity due to conditions being entailed in multiple ways. Finally, if the axioms used are stored, as just described, constructing the conversion could also be made more efficient.



\section{Example}
\label{6.4}
This section focuses on solving the constraints generated by the program in Example~\ref{complex5}. Since this program consists of nested applications, the equality constraint that arises from the type annotation will be disregarded, until further notice, in order to better showcase the graph-based constraint solver.
\subsection{Substituting Type Variables}
Recall that the equality constraints $E$ generated by Example \ref{complex5} were \{$Float\to \text{CHF} \sim b_1 \to b_2, a \to a \to (\text{Wallet} \; a) \sim b_3 \to b_4$, $Float \to \text{DKK} \sim b_5 \to b_6$, $b_4 \sim b_7 \to b_8$\} and the generated conversion constraints $Y$ were \{$\convX{\imEnv_1}{Float}{b_1},\; \convX{\imEnv_1}{b_2}{b_3}$,\; $\convX{\imEnv_2}{Int}{b_5}$,\; $\convX{\imEnv_1}{b_6}{b_7}$ \}.

Performing unification on $E$ results in the substitution $\Theta= [b_1 \mapsto Float, \;b_2 \mapsto \text{CHF}, \;b_3 \mapsto a, \;b_4 \mapsto a \to \text{Wallet }a, \;b_5 \mapsto Float, \;b_6 \mapsto \text{DKK},\;b_7 \mapsto a,\;b_8 \mapsto \text{Wallet }a]$. The application of $\Theta$ to $Y$ yields the updated constraints $Y' = \{(j_1,\convX{\imEnv_1}{Float}{Float})$, $(j_2,\convX{\imEnv_1}{\text{CHF}}{a})$, $(j_3,\convX{\imEnv_2}{Int}{Float}),\;(j_4,\convX{\imEnv_1}{\text{DKK}}{a}) \}$.

This example results in the very simple graph presented in \fref{6a}. Both constraints are indexed by the environment $\imEnv_1 = \{\lambda \tmVar . K_{\text{EUR}}\; 28.0 : \text{DKK} \rightsquigarrow \text{EUR}, \;\lambda \tmVar . K_{\text{EUR}}\; 1.2 : {\text{CHF}} \rightsquigarrow {\text{EUR}},\; {\lambda \tmVar . K_{\text{USD}}\; 3.4} : {\text{EUR}} \rightsquigarrow {\text{USD}},\; (\lambda \tmVar. case\;\tmVar\; of\;K_{\text{Wallet}}\;y_1\;y_2 \to K_{\text{Wallet}} (j\;y_1)\;(j\;y_2)) :(\forall a, b . j : a \rightsquigarrow b \Rightarrow \text{Wallet}\;a\rightsquigarrow \text{Wallet}\;b)\}$ (in \fref{6b}).
\begin{figure}
  \centering
  \begin{subfigure}{.25\textwidth}
    \centering
    \includegraphics[width=\linewidth]{6a}
    \caption{Plot of the constraints with type variables. Both are indexed by $I_1$.}
    \label{6a}
  \end{subfigure}
  \begin{subfigure}{.40\textwidth}
    \centering
    \includegraphics[width=\linewidth]{6b}
    \caption{The implicit environment $\imEnv_1$.}
    \label{6b}
  \end{subfigure}
  \caption{}
\end{figure}


Following \ref{dominator}, the computation of the types reachable from CHF and from DKK  results in, respectively, \{ CHF, EUR, USD \} and \{DKK, EUR, USD\}. The intersection of these sets is \{ EUR, USD\} and, as such all paths from CHF and from DKK to both EUR and USD must be computed. EUR is the dominator since it is present in these paths and, as such, should replace $a$ in all the conversion constraints.
\subsection{Constructing the Conversions}
Entailing the conversion constraint and constructing the converting expression can (and should) be handled simultaneously. The first constraint $(j_1,\convX{\imEnv_1}{Float}{Float})$ is trivially entailed. As such $j_1$ should be replaced by the identity function.

Regarding the conversion $(j_2,\convX{\imEnv_1}{\text{CHF}}{\text{EUR}})$, note that only one conversion axiom is applicable to the type CHF: $\lambda \tmVar . K_{\text{EUR}}\; 1.2$. This axiom has no conditions, so it is applicable and can not introduce ambiguity by itself. The set of paths under construction becomes CHF $\to$ EUR and is bound to the converting expression $\lambda \tmVar . K_{\text{EUR}}\; 1.2 $. Because EUR is the target type of the constraint, this path is not extended; and since it is the only path under construction, the implicit conversion is not ambiguous. Hence, $j_2$ will be replaced by $\lambda \tmVar . K_{\text{EUR}}\; 1.2 $.

The constraints $(j_3,\convX{\imEnv_2}{Int}{Float})$ and $(j_4,\convX{\imEnv_1}{\text{DKK}}{EUR})$ are treated in a completely identical manner. The place-holders $j_3$ and $j_4$ are replaced by, respectively, $\lambda \tmVar.3.1415$ and $\lambda \tmVar . K_{\text{EUR}}\; 28.0$.

Applying these substitutions to the partially elaborated program (shown in \fref{partialElab}) results in the fully elaborated program presented in \fref{fullyElab}.
\begin{figure}
     \[
\begin{array}{@{\hspace{0mm}}l@{\hspace{0mm}}}
  data\;\text{EUR}=K_{\text{EUR}}\;Float;\\
  data\;\text{CHF}=K_{\text{EUR}}\;Float;;\\
  data\;\text{DKK}=K_{\text{DKK}}\;Float;\\
  data\;\text{USD}=K_{\text{USD}}\;Float;\\
  data\;\text{Wallet}\;\tyVar=K_{\text{Wallet}}\; \tyVar \; \tyVar;\\[3mm]
  (K_{\text{Wallet}}\;\\\phantom{xx}((\lambda \tmVar . K_{\text{EUR}}\; 1.2)\;(K_{\text{CHF}}\;((\lambda \tmVar . \tmVar)\; 5.25)))\;\\\phantom{xx}((\lambda \tmVar . K_{\text{EUR}}\; 28.0)\; (K_{\text{DKK}}\;((\lambda \tmVar.3.1415)\;1))))

\end{array}
\]
\caption{Partial elaboration of the TrIC program in Example \ref{complex5}.}
\label{fullyElab}
\end{figure}

\subsubsection{Slightly More Complex Conversions}
The conversion constraints generated were quite simple. More interesting constraints to consider are $(j_l,\convX{\imEnv_1}{\text{CHF}}{\text{USD}})$, $(j_m,\convX{\imEnv_1}{\text{Wallet CHF}}{\text{Wallet EUR}})$ and $(j_n,\convX{\imEnv_1}{\text{Wallet CHF}}{\text{Wallet USD}})$. The idea is always the same: starting from the source type, conversion axioms are applied in order to reach the target type.

Regarding the first, only one axiom matches its source type: $(\lambda \tmVar . K_{\text{EUR}}\; 1.2) : {\text{CHF}} \rightsquigarrow {\text{EUR}}$. As before, the set of paths under construction becomes CHF $\to$ EUR and is bound to the converting expression $\lambda \tmVar . ((\lambda \tmVar_1 . K_{\text{EUR}}\; 1.2)\; \tmVar)$. Again, only one axiom applies to the last type of the path under construction: ${(\lambda \tmVar . K_{\text{USD}}\; 3.4)} : {\text{EUR}} \rightsquigarrow {\text{USD}}$, resulting in an updated path (CHF $\to$ EUR $\to$ USD) and corresponding expression: $\lambda \tmVar . (({\lambda \tmVar_1 . K_{\text{USD}}\; 3.4})\;((\lambda \tmVar_2 . K_{\text{EUR}}\; 1.2)\;\tmVar))$. We have arrived at the target type of the constraint, so there is a path; as there is solely one path, this constraint is unambiguously entailed, and the corresponding converting expression has been computed.

As for the constraint bound to $j_m$, Wallet CHF can be made to match the source type of only one axiom:
\begin{itemize}
\item$(\lambda \tmVar. case\;\tmVar\; of\;K_{\text{Wallet}}\;y_1\;y_2 \to K_{\text{Wallet}} (j\;y_1)\;(j\;y_2)) : (\forall a, b . j : a \rightsquigarrow b \Rightarrow \text{Wallet}\;a\rightsquigarrow \text{Wallet}\;b)$
\end{itemize}
Unifying type Wallet CHF with Wallet $a$ and applying the resulting type substitution to the type of the axiom yields $\forall b . j : CHF \rightsquigarrow b \Rightarrow \text{Wallet CHF}\rightsquigarrow \text{Wallet}\;b$.

As stated in Section \ref{uat}, each type for which there is a conversion $\convX{\imEnv_1}{\text{CHF}}{\type}$ will now be considered. \fref{6b} shows that $b$ can (apart from the trivial conversion) be substituted by EUR and USD, and the converting expressions are, respectively, ``$\lambda \tmVar . K_{\text{EUR}}\; 1.2$'' and ``$(\lambda \tmVar . K_{\text{USD}}\; 3.4)\;(\lambda \tmVar . K_{\text{EUR}}\; 1.2)$''. As such, two instances of the parametric axiom to be applicable:
\begin{itemize}
  \item $(\lambda \tmVar. case\;\tmVar\; of\;K_{\text{Wallet}}\;y_1\;y_2 \to \\ K_{\text{Wallet}} ((\lambda \tmVar . K_{\text{EUR}}\; 1.2)\;y_1)\;((\lambda \tmVar . K_{\text{EUR}}\; 1.2)\;y_2))\\  : (\text{Wallet CHF}\rightsquigarrow \text{Wallet EUR})$;

  \item $(\lambda \tmVar. case\;\tmVar\; of\;K_{\text{Wallet}}\;y_1\;y_2  \to \\ K_{\text{Wallet}} (((\lambda \tmVar . K_{\text{USD}}\; 3.4)\;(\lambda \tmVar . K_{\text{EUR}}\; 1.2))\;y_1)\;(((\lambda \tmVar . K_{\text{USD}}\; 3.4)\;(\lambda \tmVar . K_{\text{EUR}}\; 1.2))\;y_2)) \\ : (\text{Wallet CHF}\rightsquigarrow \text{Wallet USD})$
\end{itemize}

This results in two paths under construction: Wallet CHF $\to$ Wallet EUR and Wallet CHF $\to$ Wallet USD. The last type of the first path is the target type of the constraint, thus the constraint is entailable and ``$\lambda \tmVar . (\lambda \tmVar_1. case\;\tmVar_1\; of\;K_{\text{Wallet}}\;y_1\;y_2 \to \\ K_{\text{Wallet}} ((\lambda \tmVar_2 . K_{\text{EUR}}\; 1.2)\;y_1)\;((\lambda \tmVar_3 . K_{\text{EUR}}\; 1.2)\;y_2))\;\tmVar$'' is a possible converting expression.

However, the other path under construction must also be considered. If it too leads to Wallet EUR, the constraint can be entailed in multiple ways. The parametric axiom is once again the only that needs to be considered. However, since it is not possible to implicitly convert from USD to any other type, the axiom can not be applied and the path is disregarded.

Finally, consider $(j_n,\convX{\imEnv_1}{\text{Wallet CHF}}{\text{Wallet USD}})$. The process to check the entailability of this conversion starts exactly as the previous and results in the same two paths under construction and corresponding converting expressions. As one of the paths ends in the target type of the conversion, we know it to be entailable. Nonetheless, we must continue to explore the other. The parametric axiom can be applied to Wallet EUR to convert it to Wallet USD, \textit{i.e.}, the path becomes Wallet CHF $\to$ Wallet EUR $\to$ Wallet USD. There are two possible paths (Wallet CHF $\to$ Wallet USD and Wallet CHF $\to$ Wallet EUR $\to$ Wallet USD) and, as such, the constraint is not unambiguously entailed under the current implicit environment, causing the program to be rejected.
