\chapter{Introduction}
\label{cha:intro}
We build tools to make our life easier. The goal is to minimize the work needed to solve some problem, provided that we retain full control on how our problem is being solved. Washing machines wash our dirty laundry but we choose the temperature, we do not let them guess it. However, if we were sure that the machines could infer the right temperature by the laundry it has been fed, we would be glad that it is now easier to have clean clothes.

Programming languages are tools. They have been evolving over the past decades allowing us to solve more problems and/or solve them in a better way. ``A better way'' is not restricted to the final solution alone: the process of writing the code should also be taken into account. Languages with static typing allow the detection of erroneous code sooner, at compile-time. However, static typing can lead to a reduction in the expressivity of a language and to the need of explicitly writing the types in the programs.

The Hindley-Milner type system \cite{damas,hm2,hm3} is a perfect example of a breakthrough in the programming language research. While being a powerful enough language in which a great variety of programs can be expressed, Hindley-Milner improves on System F by eliminating a burden for the user: the need for explicitly annotating the programs (at the cost of restricting System F's expressiveness).  In turn, System F improves on the less sophisticated Simply Typed Lambda Calculus since it enables code re-use by allowing functions to be defined once and applicable to arguments of any type.

Implicit programming mechanisms ``infer values by a type-directed resolution process, making programs more compact and easier to read''(\cite{cochis}). Implicit programming features have surfaced in a number of languages: from Haskell \cite{adhoc} and Coq's \cite{coq} type classes, to Agda's implicit arguments \cite{agda} and to Rust's traits \cite{rust}, to name a few. 

Scala \cite{scala} is a widely used programming language that enables the use of implicit parameters and implicit conversions. This means that a parameter can be omitted from a function and Scala will fetch it (under certain conditions); and that functions can be applied to arguments of a different type, as long as there is an implicit conversion from the type of the provided argument to the type of the expected argument. As an example, if an implicit conversion from the type Euro to the type Dollar is in scope, a program that expects Dollars  will behave seamlessly in cases where an argument of type Euro is provided, \textit{i.e.}, as if its argument was the corresponding amount in Dollars.

Nonetheless, there is room for improvement: as the technology stands now, given an implicit conversion from Euro to Dollar and one from Dollar to Pounds, Scala's implicit conversions will not be able to take the two steps and implicitly convert from Euro to Pound. This text presents TrIC, a language that supports transitivity in its implicit type conversions, thus allowing the programmer to avoid writing tedious conversions and thus also possibly avoiding some annoying bugs.

Furthermore, TrIC supports novel features regarding implicit conversions, from local scoping to multiple constrained conversions. User-friendliness is taken into account so that this extension behaves in a way the user can easily predict. This is not currently the case: Chapter \ref{cha:4} provides an example of implicit conversions in Scala, leading the execution of our program down unintended paths.

The structure of this text is as follows:
\begin{itemize}
\item Chapters \ref{cha:2} and \ref{cha:3} provide the necessary background for the rest of this thesis;
\item Chapter \ref{cha:4} introduces implicit type conversions (ITC), presents the state of the art discusses the desirable aspects of a language with support for ITC;
\item Chapter \ref{cha:5} presents TrIC, a small core language with user-defined ITC, and the generation of constraints required for compiling TrIC programs;
\item Chapter \ref{cha:6} explains how the aforementioned constraints are entailed and how the program is compiled;
\item In Chapter \ref{cha:7}, a version of TrIC with support for type classes (TrICx) is studied.
\item Finally, Chapter \ref{cha:8} discusses the related work and Chapter \ref{cha:9} concludes.
\end{itemize}

This thesis resulted in the extension of the KU Leuven Haskell compiler (KHC) to support the features discusses in the text. The implementation of the extended KHC is available at \href{https://github.com/mesqg/thesis}{https://github.com/mesqg/thesis}. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
